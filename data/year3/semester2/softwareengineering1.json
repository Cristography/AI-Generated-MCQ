[
    {
        "question": "ما هو المصطلح الذي يصف عملية التحقق من أن البرنامج ينجز ما يريده الزبون؟",
        "options": [
            "Verification (التحقق)",
            "Validation (المصادقة)",
            "Evolution (التطوير)",
            "Specification (التوصيف)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الـ Validation (المصادقة) هي عملية التأكد من أننا نبني المنتج الصحيح الذي يلبي احتياجات المستخدم (Are we building the right product?). بينما الـ Verification هي التأكد من أننا نبني المنتج بشكل صحيح (Are we building the product right?)."
    },
    {
        "question": "في أي نموذج لتطوير البرمجيات يتم تسليم نسخة أولية للمستخدم للحصول على تغذية راجعة مبكرة، ومن ثم يتم تحسينها أو التخلص منها؟",
        "options": [
            "النموذج الشلالي (Waterfall)",
            "نموذج النمذجة الأولية (Prototyping)",
            "النموذج الحلزوني (Spiral)",
            "النموذج التزايدي (Incremental)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "نموذج النمذجة الأولية يركز على بناء نسخة أولية (بروتوتايب) بسرعة لعرضها على المستخدم وجمع الملاحظات، مما يساعد في فهم المتطلبات بشكل أفضل قبل البدء بالتطوير الكامل."
    },
    {
        "question": "أي نوع من الاختبارات يفحص النظام دون معرفة ببنيته الداخلية أو الكود المصدري؟",
        "options": [
            "اختبار الصندوق الأبيض (White-box)",
            "اختبار الوحدة (Unit test)",
            "اختبار الصندوق الأسود (Black-box)",
            "اختبار التكامل (Integration test)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "اختبار الصندوق الأسود يتعامل مع البرنامج كوحدة مغلقة، حيث يتم إدخال مدخلات ومراقبة المخرجات للتأكد من أنها تتوافق مع المتطلبات، دون النظر إلى كيفية عمل البرنامج من الداخل."
    },
    {
        "question": "ما هي المرحلة التي تسبق مرحلة 'تحليل المتطلبات' في دورة حياة المشروع البرمجي؟",
        "options": [
            "التصميم (Design)",
            "البرمجة (Implementation)",
            "دراسة الجدوى (Feasibility Study)",
            "الصيانة (Maintenance)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "قبل البدء بجمع وتحليل المتطلبات بشكل مفصل، يجب إجراء دراسة جدوى لتحديد ما إذا كان المشروع قابلاً للتنفيذ من النواحي التقنية والاقتصادية والتشغيلية."
    },
    {
        "question": "متطلب 'يجب أن يكون النظام متوافقاً مع قانون حماية البيانات GDPR' يصنف على أنه:",
        "options": [
            "متطلب وظيفي (Functional)",
            "متطلب غير وظيفي - خارجي (External Non-functional)",
            "متطلب غير وظيفي - منتج (Product Non-functional)",
            "متطلب غير وظيفي - تنظيمي (Organizational Non-functional)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "المتطلبات القانونية والتشريعية هي قيود مفروضة على النظام من بيئته الخارجية، وبالتالي تصنف كمتطلبات غير وظيفية خارجية."
    },
    {
        "question": "في النموذج الحلزوني (Spiral Model)، ما هو النشاط الرئيسي الذي يتم في كل دورة ويجعله متميزاً عن النماذج الأخرى؟",
        "options": [
            "كتابة الكود البرمجي",
            "تصميم واجهة المستخدم",
            "تحليل وإدارة المخاطر",
            "توثيق المتطلبات فقط"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الميزة الأساسية للنموذج الحلزوني هي تركيزه على تحليل المخاطر في كل لفة من الحلزون، مما يساعد على التعامل مع المشاريع الكبيرة والمعقدة التي تحمل درجة عالية من عدم اليقين."
    },
    {
        "question": "ما هو الفرق الرئيسي بين المنتج البرمجي (Software Product) والإجراء البرمجي (Software Process)؟",
        "options": [
            "المنتج هو الكود، والإجراء هو التوثيق",
            "المنتج هو البرنامج النهائي، والإجراء هو عملية تكوينه",
            "لا يوجد فرق بينهما",
            "المنتج هو للأغراض التجارية فقط، والإجراء للأغراض الأكاديمية"
        ],
        "correctAnswerIndex": 1,
        "explanation": "المنتج البرمجي هو البرنامج القابل للاستخدام الذي يتم تسليمه للعميل، بينما الإجراء البرمجي هو مجموعة الخطوات والعمليات المنهجية المتبعة لإنشاء هذا المنتج."
    },
    {
        "question": "أي من الخصائص التالية لا تعتبر من أبعاد الاعتمادية (Dependability) الأساسية؟",
        "options": [
            "الموثوقية (Reliability)",
            "السلامة (Safety)",
            "التكلفة (Cost)",
            "الأمن (Security)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الاعتمادية تشمل خصائص مثل الإتاحة، الموثوقية، السلامة، والأمن. التكلفة هي قيد من قيود المشروع ولكنها ليست بعداً من أبعاد الاعتمادية للنظام نفسه."
    },
    {
        "question": "الفشل الذي يحدث فقط عند مجموعة محددة من المدخلات ويختفي عند إعادة التشغيل أو مع مدخلات أخرى يسمى:",
        "options": [
            "فشل دائم (Permanent Failure)",
            "فشل عابر (Transient Failure)",
            "فشل مسبب للعطب (Corrupting Failure)",
            "فشل قابل للإصلاح (Recoverable Failure)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الفشل العابر هو الذي يظهر تحت ظروف معينة ومدخلات محددة، ولا يتكرر بشكل دائم مع كل المدخلات، مما يجعله صعب الكشف أحياناً."
    },
    {
        "question": "في لغة التوصيف النظامية Z، ماذا يعني استخدام الرمز (∆) قبل اسم المخطط (Schema)؟",
        "options": [
            "أن العملية لا تغير حالة النظام",
            "أن العملية تغير حالة النظام",
            "أن العملية تتطلب مدخلاً من المستخدم",
            "أن العملية تنتج مخرجاً"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الرمز ∆ (دلتا) يشير إلى أن العملية أو العملية الموصوفة في المخطط ستؤدي إلى تغيير في حالة متغير واحد أو أكثر من متغيرات النظام. بينما الرمز Ξ (Xi) يعني أن الحالة تبقى دون تغيير."
    },
    {
        "question": "ما هو الهدف من 'تحليل شجرة الخطأ' (Fault Tree Analysis)؟",
        "options": [
            "البدء من فشل محتمل وتحديد الأسباب التي قد تؤدي إليه",
            "البدء من سبب وتحديد النتائج المحتملة له",
            "حساب عدد الأخطاء في الكود",
            "رسم مخطط تدفق التحكم للبرنامج"
        ],
        "correctAnswerIndex": 0,
        "explanation": "تحليل شجرة الخطأ هي تقنية تحليل للمخاطر تبدأ من الأعلى إلى الأسفل (Top-down)، حيث يتم تحديد حدث فشل غير مرغوب فيه (الجذر) ثم يتم تحليل النظام لتحديد جميع الأسباب المحتملة التي يمكن أن تؤدي إلى هذا الفشل."
    },
    {
        "question": "قدرة النظام على الاستمرار في تقديم الخدمات الأساسية حتى أثناء تعرضه لهجوم أو فشل جزئي هي خاصية:",
        "options": [
            "الموثوقية (Reliability)",
            "قابلية البقاء على قيد الحياة (Survivability)",
            "قابلية الصيانة (Maintainability)",
            "السلامة (Safety)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "قابلية البقاء على قيد الحياة (أو التسامح مع الهجوم) هي مقياس لقدرة النظام على مقاومة الهجمات ومواصلة العمل، حتى لو كان ذلك بوظائف محدودة، بدلاً من الانهيار الكامل."
    },
    {
        "question": "أي من التالي يصف 'هندسة النظام' (System Engineering) بشكل أفضل مقارنة بـ 'هندسة البرمجيات'؟",
        "options": [
            "تركز فقط على كتابة الكود البرمجي",
            "هي جزء من هندسة البرمجيات",
            "تتعامل مع جميع مكونات النظام بما في ذلك الأجهزة والبرمجيات والأفراد",
            "مسؤولة عن اختبار البرمجيات فقط"
        ],
        "correctAnswerIndex": 2,
        "explanation": "هندسة النظام لها نظرة أشمل، حيث تهتم بتصميم وتكامل جميع عناصر النظام (أجهزة، برمجيات، عمليات، أفراد)، بينما هندسة البرمجيات هي تخصص يركز على الجانب البرمجي من هذا النظام."
    },
    {
        "question": "في سياق اختبار الصندوق الأبيض، ما هو 'المتغير الحي' (liveness variable)؟",
        "options": [
            "متغير يحتفظ بقيمته بين استدعاءات الدالة",
            "متغير يستخدم في حلقة لا نهائية",
            "متغير تم تعريفه وحجز مكان له في الذاكرة ولكنه لا يستخدم أبداً",
            "متغير عام يمكن الوصول إليه من أي مكان في البرنامج"
        ],
        "correctAnswerIndex": 2,
        "explanation": "خلال فحص الصندوق الأبيض، البحث عن متغيرات غير مستخدمة (liveness variable) يعتبر من الممارسات الجيدة، لأن هذه المتغيرات تحجز موارد الذاكرة دون فائدة ويمكن أن تشير إلى وجود خطأ منطقي أو كود مهمل."
    },
    {
        "question": "ما هو الهدف الرئيسي من استخدام أدوات CASE في هندسة البرمجيات؟",
        "options": [
            "زيادة سرعة معالج الكمبيوتر",
            "توفير دعم مؤتمت (آلي) لعمليات دورة حياة تطوير البرمجيات",
            "كتابة أنظمة تشغيل جديدة",
            "تقليل عدد المبرمجين في الفريق"
        ],
        "correctAnswerIndex": 1,
        "explanation": "أدوات CASE (Computer-Aided Software Engineering) مصممة لأتمتة ودعم الأنشطة المختلفة في تطوير البرمجيات، مثل التحليل، التصميم، كتابة الكود، والاختبار، بهدف زيادة الإنتاجية والجودة."
    },
    {
        "question": "أي من المشاكل التالية لا يعتبر من مشاكل استخدام اللغة الطبيعية في كتابة المتطلبات؟",
        "options": [
            "الغموض (Ambiguity)",
            "دمج متطلبات مختلفة في جملة واحدة (Mixing)",
            "عدم الدقة (Imprecision)",
            "التوصيف الرياضي الدقيق (Precise mathematical specification)"
        ],
        "correctAnswerIndex": 3,
        "explanation": "الغموض ودمج المتطلبات وعدم الدقة هي من العيوب الشائعة للغة الطبيعية. أما التوصيف الرياضي الدقيق، فهو سمة من سمات الطرق النظامية (Formal Methods) التي تستخدم للتغلب على مشاكل اللغة الطبيعية."
    },
    {
        "question": "عندما نقول 'الخلل (fault) لا يؤدي بالضرورة إلى فشل (failure)'، ماذا يعني ذلك؟",
        "options": [
            "كل خلل يسبب فشلاً فورياً",
            "قد يتم تصحيح الخطأ الناتج عن الخلل داخلياً قبل أن يلاحظه المستخدم",
            "الخلل والفشل هما نفس الشيء",
            "الخلل يحدث فقط في الأجهزة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الخلل هو عيب في الكود. قد ينتج عنه حالة خطأ داخلية (error)، ولكن النظام قد يحتوي على آليات (مثل معالجة الاستثناءات) تتجاوز هذا الخطأ أو تصححه، وبالتالي لا يحدث فشل خارجي يمكن ملاحظته."
    },
    {
        "question": "في مخطط تدفق البيانات (DFD)، ما هو العنصر الذي يمثل مصدراً أو مستهلكاً للبيانات خارج حدود النظام؟",
        "options": [
            "العملية (Process)",
            "مخزن البيانات (Data Store)",
            "تدفق البيانات (Data Flow)",
            "الكيان الخارجي (External Entity)"
        ],
        "correctAnswerIndex": 3,
        "explanation": "الكيان الخارجي (أو المصدر/المصب) يمثل شخصاً، أو قسماً، أو نظاماً آخر يتفاعل مع نظامنا عن طريق إرسال البيانات إليه أو استقبال البيانات منه، وهو يقع خارج نطاق التحكم المباشر للنظام."
    },
    {
        "question": "ماذا يمثل 'مخطط السياق' (Context Diagram) في DFD؟",
        "options": [
            "التفاصيل الدقيقة لعملية واحدة",
            "نظرة عامة عالية المستوى للنظام كعملية واحدة مع كياناته الخارجية",
            "مخازن البيانات فقط",
            "العلاقات بين الموظفين في المشروع"
        ],
        "correctAnswerIndex": 1,
        "explanation": "مخطط السياق (أو المستوى صفر) هو أعلى مستوى من التجريد في DFD، حيث يظهر النظام بأكمله كعملية واحدة (دائرة واحدة) ويوضح تدفقات البيانات الرئيسية بينه وبين الكيانات الخارجية التي يتفاعل معها."
    },
    {
        "question": "عملية 'التحسين' (Evolution) في دورة حياة البرمجيات تشير إلى:",
        "options": [
            "عملية إنتاج البرمجية من خلال التصميم والبرمجة فقط",
            "التحقق من صحة أن البرنامج ينجز ما يريده الزبون",
            "تغيير وتعديل البرنامج استجابة للمتطلبات المتغيرة أو لإصلاح الأخطاء",
            "تحديد المهام المطلوبة من النظام"
        ],
        "correctAnswerIndex": 2,
        "explanation": "مرحلة التحسين أو الصيانة التطورية هي المرحلة التي تلي تسليم المنتج، وتتضمن إجراء تعديلات وتحسينات على البرنامج لمواكبة التغيرات في بيئة العمل أو متطلبات المستخدم أو لإصلاح الأخطاء المكتشفة."
    },
    {
        "question": "ما هو المقياس الذي يعبر عن 'احتمال تشغيل النظام على مدى فترة زمنية معينة في بيئة معينة لغرض معين وبدون حدوث فشل'؟",
        "options": [
            "الإتاحية (Availability)",
            "الموثوقية (Reliability)",
            "السلامة (Safety)",
            "قابلية الصيانة (Maintainability)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الموثوقية (Reliability) هي مقياس لاحتمالية عمل النظام بشكل صحيح ومستمر لفترة زمنية محددة تحت ظروف معينة. تختلف عن الإتاحية التي تقيس احتمالية أن يكون النظام جاهزاً للعمل في لحظة معينة."
    },
    {
        "question": "في تقنية PERT، كيف يتم حساب الزمن المتوقع (Expected Time) لنشاط ما؟",
        "options": [
            "(المتفائل + المتشائم) / 2",
            "(المتفائل + 4 * الأكثر احتمالاً + المتشائم) / 6",
            "الأكثر احتمالاً",
            "(المتفائل + 2 * الأكثر احتمالاً + المتشائم) / 4"
        ],
        "correctAnswerIndex": 1,
        "explanation": "تستخدم تقنية PERT التوزيع الاحتمالي بيتا لتقدير زمن النشاط، والصيغة المستخدمة هي المتوسط المرجح: (الزمن المتفائل + 4 * الزمن الأكثر احتمالاً + الزمن المتشائم) مقسوماً على 6."
    },
    {
        "question": "ما هو 'المسار الحرج' (Critical Path) في مخطط PERT؟",
        "options": [
            "أقصر مسار في المشروع",
            "المسار الذي يحتوي على أقل عدد من الأنشطة",
            "أطول مسار في المشروع من حيث الزمن",
            "المسار الذي يحتوي على أكثر المخاطر"
        ],
        "correctAnswerIndex": 2,
        "explanation": "المسار الحرج هو أطول مسار زمني عبر شبكة المشروع. أي تأخير في أي نشاط على هذا المسار سيؤدي إلى تأخير المشروع بأكمله، وهو يحدد الحد الأدنى من الزمن اللازم لإنجاز المشروع."
    },
    {
        "question": "في مخطط تدفق التحكم (CFG)، ماذا تمثل العقد (Nodes)؟",
        "options": [
            "المتغيرات في البرنامج",
            "التعليقات في الكود",
            "مجموعة من التعليمات البرمجية التي تنفذ بشكل متسلسل",
            "المستخدمين النهائيين للنظام"
        ],
        "correctAnswerIndex": 2,
        "explanation": "في CFG، كل عقدة تمثل كتلة أساسية (Basic Block)، وهي سلسلة من التعليمات التي يتم تنفيذها دائمًا واحدة تلو الأخرى، بدون نقاط تفرع أو قفزات داخلها."
    },
    {
        "question": "أي من العبارات التالية صحيحة بخصوص النموذج الشلالي (Waterfall)؟",
        "options": [
            "مرن جداً ويسمح بالتعديلات بسهولة في أي مرحلة",
            "يتم تسليم نسخة عاملة من البرنامج في وقت مبكر جداً",
            "يتطلب أن تكون المتطلبات واضحة ومستقرة قبل البدء بالتصميم",
            "يعتمد على تحليل المخاطر في كل مرحلة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "من أهم خصائص (وعيوب) النموذج الشلالي هو طبيعته التتابعية الصارمة، والتي تفترض أن المتطلبات يمكن تحديدها بالكامل وبشكل دقيق في البداية، حيث أن العودة إلى مرحلة سابقة لإجراء تعديلات أمر مكلف وصعب."
    },
    {
        "question": "مصطلح 'المخاطرة' (Risk) في هندسة البرمجيات هو مقياس يجمع بين:",
        "options": [
            "عدد أسطر الكود والتكلفة",
            "احتمالية وقوع حدث سلبي وشدة الضرر الناتج عنه",
            "سرعة النظام وذاكرته المستخدمة",
            "خبرة الفريق والوقت المتاح"
        ],
        "correctAnswerIndex": 1,
        "explanation": "يتم تقييم المخاطرة عادةً كحاصل ضرب احتمالية حدوث الخطر (Hazard) في شدة العواقب أو الضرر (Damage) الذي سينجم عن هذا الخطر في حال وقوعه."
    },
    {
        "question": "أي نوع من الاختبارات يتم فيه فحص تفاعل وتكامل وحدات برمجية مختلفة مع بعضها البعض؟",
        "options": [
            "اختبار الوحدة (Unit Testing)",
            "اختبار التكامل (Integration Testing)",
            "اختبار النظام (System Testing)",
            "اختبار القبول (Acceptance Testing)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "بعد اختبار كل وحدة برمجية على حدة (اختبار الوحدة)، يتم تجميع هذه الوحدات واختبارها معاً في مرحلة اختبار التكامل للتأكد من أنها تعمل بشكل صحيح وتتبادل البيانات كما هو متوقع."
    },
    {
        "question": "ماذا تعني خاصية 'الإتاحية' (Availability) للنظام؟",
        "options": [
            "أن النظام لا يحتوي على أي أخطاء",
            "احتمال أن يكون النظام جاهزاً للعمل ويقدم الخدمة عند الطلب في لحظة معينة",
            "أن النظام آمن ضد الهجمات الخارجية",
            "أن النظام سهل الصيانة والتطوير"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الإتاحية هي مقياس لنسبة الوقت الذي يكون فيه النظام قادراً على استقبال الطلبات ومعالجتها. وتأخذ في الاعتبار كلاً من متوسط الوقت بين الأعطال (MTBF) ومتوسط الوقت اللازم للإصلاح (MTTR)."
    },
    {
        "question": "في لغة Z، ما هي وظيفة الجزء المسمى 'Predicate' داخل المخطط (Schema)؟",
        "options": [
            "تعريف المتغيرات وأنواعها",
            "تحديد اسم المخطط",
            "وصف العلاقات والقيود الثابتة التي يجب أن تظل صحيحة بين المتغيرات",
            "كل ما سبق خاطئ"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الجزء العلوي من المخطط (Declarations) يعرّف المتغيرات. أما الجزء السفلي (Predicate) فيحدد القيود أو الشروط (Invariants) التي يجب أن تتحقق دائماً في أي حالة من حالات النظام."
    },
    {
        "question": "مفهوم 'موازنة مخطط تدفق البيانات' (DFD Balancing) يعني:",
        "options": [
            "أن عدد العمليات يجب أن يكون مساوياً لعدد مخازن البيانات",
            "أن المخطط يجب أن يكون متناظراً شكلياً",
            "أن تدفقات البيانات الداخلة والخارجة لعملية ما في مستوى أعلى يجب أن تتطابق مع مجموع التدفقات الداخلة والخارجة لتفصيلها في المستوى الأدنى",
            "أن جميع تدفقات البيانات يجب أن تحمل نفس الاسم"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الموازنة هي قاعدة أساسية تضمن الاتساق بين مستويات DFD المختلفة. وتعني أن أي بيانات تدخل أو تخرج من عملية 'أم' في مستوى معين يجب أن تظهر أيضاً وهي تدخل أو تخرج من مخططها التفصيلي (الابن) في المستوى التالي."
    },
    {
        "question": "أي مما يلي يعتبر مثالاً على 'متطلب وظيفي'؟",
        "options": [
            "يجب أن يكون النظام متاحاً بنسبة 99.9%",
            "يجب أن يستخدم النظام لغة البرمجة Java",
            "يجب أن يتمكن المستخدم من طباعة الفاتورة",
            "يجب أن تكون واجهة المستخدم سهلة الاستخدام"
        ],
        "correctAnswerIndex": 2,
        "explanation": "المتطلبات الوظيفية تصف 'ماذا' يفعل النظام، أي الخدمات والوظائف التي يقدمها. 'طباعة الفاتورة' هي خدمة محددة. الخيارات الأخرى هي أمثلة على متطلبات غير وظيفية (موثوقية، تحقيق، قابلية استخدام)."
    },
    {
        "question": "ما هو الخلل (Fault) الذي يتطلب تدخل المشغل لإعادة النظام إلى حالته الطبيعية؟",
        "options": [
            "خلل قابل للإصلاح (Recoverable)",
            "خلل غير قابل للإصلاح (Unrecoverable)",
            "خلل عابر (Transient)",
            "خلل لا يسبب العطب (Non-corrupting)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الخلل غير القابل للإصلاح هو الذي لا يمكن للنظام التعافي منه تلقائياً، ويتطلب تدخلاً يدوياً من المستخدم أو المشغل لاستعادة النظام."
    },
    {
        "question": "الطبقة التي تعتبر 'حجر الأساس' في نموذج التكنولوجيا الطبقية لهندسة البرمجيات هي:",
        "options": [
            "الأدوات (Tools)",
            "الطرق (Methods)",
            "العملية (Process)",
            "التركيز على الجودة (Quality Focus)"
        ],
        "correctAnswerIndex": 3,
        "explanation": "تعتبر الجودة هي الأساس الذي ترتكز عليه جميع طبقات هندسة البرمجيات الأخرى (العملية، الطرق، الأدوات). بدون الالتزام بالجودة، تفقد الطبقات الأخرى قيمتها."
    },
    {
        "question": "ما هو 'اختبار القبول' (Acceptance Testing)؟",
        "options": [
            "اختبار كل وحدة برمجية بشكل منفصل",
            "اختبار يقوم به فريق التطوير للتأكد من تكامل الوحدات",
            "اختبار يقوم به المستخدم النهائي أو العميل للتأكد من أن النظام يلبي احتياجاتهم وقبول تسلمه",
            "اختبار أداء النظام تحت ضغط عالٍ"
        ],
        "correctAnswerIndex": 2,
        "explanation": "اختبار القبول هو المرحلة الأخيرة من الاختبارات قبل إطلاق النظام، ويتم إجراؤه عادةً بواسطة العميل أو المستخدمين في بيئتهم للتأكد من أن النظام جاهز ويحقق أهداف العمل المتفق عليها."
    },
    {
        "question": "ما هو الضرر الرئيسي الناجم عن انعدام 'الأمن' في النظام؟",
        "options": [
            "رفض تقديم الخدمة، انعطاب البيانات، وكشف المعلومات السرية",
            "بطء استجابة النظام",
            "صعوبة استخدام الواجهة",
            "كل ما سبق صحيح"
        ],
        "correctAnswerIndex": 0,
        "explanation": "انعدام الأمن يمكن أن يؤدي إلى أضرار جسيمة مثل هجمات حجب الخدمة (Denial of Service)، وتخريب أو تغيير البيانات (Data Corruption)، وتسريب المعلومات الحساسة (Information Disclosure)."
    },
    {
        "question": "في لغة Z، كيف يتم تمييز متغيرات الإدخال (Input) ومتغيرات الإخراج (Output)؟",
        "options": [
            "الإدخال بعلامة (!) والإخراج بعلامة (؟)",
            "الإدخال بعلامة (؟) والإخراج بعلامة (!)",
            "الإدخال بحرف 'i' والإخراج بحرف 'o' قبل الاسم",
            "لا يوجد تمييز بينهما"
        ],
        "correctAnswerIndex": 1,
        "explanation": "من الأعراف المتبعة في لغة التوصيف Z، يتم إنهاء أسماء متغيرات الإدخال بعلامة استفهام (؟) وأسماء متغيرات الإخراج بعلامة تعجب (!)، مما يسهل فهم تدفق البيانات في العمليات."
    },
    {
        "question": "ما هي السمة التي تمنع النظام من إلحاق الأذى أو الضرر بالإنسان أو البيئة المحيطة به؟",
        "options": [
            "الأمن (Security)",
            "الموثوقية (Reliability)",
            "السلامة (Safety)",
            "الإتاحية (Availability)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "السلامة هي خاصية حرجة تركز على منع النظام من التسبب في حوادث تؤدي إلى أضرار بشرية أو بيئية، حتى لو كان ذلك يعني إيقاف وظائف النظام الأخرى."
    },
    {
        "question": "أي من النماذج التالية يعتبر الأنسب لمشروع صغير بمتطلبات واضحة جداً ومستقرة؟",
        "options": [
            "النموذج الحلزوني (Spiral)",
            "النموذج الشلالي (Waterfall)",
            "نموذج التطوير السريع للتطبيقات (RAD)",
            "النموذج التكراري (Iterative)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "النموذج الشلالي يعمل بشكل أفضل عندما تكون المتطلبات مفهومة جيداً ومستقرة من البداية، لأنه لا يوفر مرونة كبيرة للتغيير في المراحل المتقدمة. للمشاريع الصغيرة والواضحة، يمكن أن يكون فعالاً وبسيطاً."
    },
    {
        "question": "في DFD، هل يمكن لكيان خارجي أن يتصل مباشرة بكيان خارجي آخر؟",
        "options": [
            "نعم، دائماً",
            "لا، يجب أن يمر التدفق عبر عملية داخل النظام",
            "نعم، ولكن فقط في مخطط السياق",
            "نعم، ولكن فقط إذا كانا من نفس النوع"
        ],
        "correctAnswerIndex": 1,
        "explanation": "مخطط DFD يصف تدفق البيانات داخل النظام وفيما بينه وبين البيئة الخارجية. أي تفاعل بين كيانين خارجيين يعتبر خارج نطاق النظام ولا يتم تمثيله في المخطط."
    },
    {
        "question": "عملية التأكد من أن البرنامج تم بناؤه بشكل صحيح وفقاً للمواصفات تسمى:",
        "options": [
            "Validation (المصادقة)",
            "Testing (الاختبار)",
            "Verification (التحقق)",
            "Debugging (تصحيح الأخطاء)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الـ Verification (التحقق) يجيب على سؤال 'هل نبني المنتج بشكل صحيح؟'. وهو يتضمن مراجعات وفحوصات للتأكد من أن مخرجات كل مرحلة تتوافق مع مدخلاتها ومواصفاتها."
    },
    {
        "question": "أي مما يلي ليس من مقاييس المتطلبات غير الوظيفية المتعلقة بالمنتج؟",
        "options": [
            "الحجم (Size)",
            "الموثوقية (Reliability)",
            "لغة البرمجة المستخدمة (Programming language)",
            "قابلية الاستخدام (Usability)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الحجم والموثوقية وقابلية الاستخدام هي خصائص للمنتج النهائي. أما لغة البرمجة المستخدمة فهي قيد على عملية التطوير، وتصنف كمتطلب غير وظيفي من نوع التحقيق (Implementation) أو تنظيمي."
    },
    {
        "question": "في تحليل المخاطر، ماذا يمثل 'الخطر' (Hazard)؟",
        "options": [
            "الضرر الفعلي الذي وقع",
            "احتمالية وقوع الحادث",
            "حالة كامنة في النظام لديها القدرة على التسبب في حادث",
            "تكلفة إصلاح النظام بعد الفشل"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الخطر (Hazard) هو حالة أو ظرف يمكن أن يؤدي إلى حادث (Accident). على سبيل المثال، وجود أسلاك كهربائية مكشوفة هو خطر، بينما الصعقة الكهربائية هي الحادث."
    },
    {
        "question": "ما هي التقنية التي يتم فيها استنتاج المتطلبات من خلال جلسات عصف ذهني جماعية بين المطورين والمستخدمين؟",
        "options": [
            "المقابلات (Interviews)",
            "الاستبيانات (Questionnaires)",
            "ورش عمل JAD (Joint Application Design)",
            "مراقبة المستخدم (Observation)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "تقنية JAD هي عبارة عن ورش عمل منظمة تجمع أصحاب المصلحة (مستخدمين، مطورين، محللين) في مكان واحد لتحديد وتوثيق المتطلبات بشكل تعاوني ومكثف."
    },
    {
        "question": "النموذج المبني على تجميع المكونات (Component-based) يركز على:",
        "options": [
            "بناء كل شيء من الصفر",
            "إعادة استخدام المكونات البرمجية الجاهزة لتكوين النظام",
            "كتابة المتطلبات باللغة الطبيعية فقط",
            "تجنب مرحلة الاختبار"
        ],
        "correctAnswerIndex": 1,
        "explanation": "هذا النموذج يهدف إلى تسريع عملية التطوير وخفض التكلفة عن طريق تجميع النظام من مكونات برمجية موجودة مسبقًا (سواء كانت تجارية أو مطورة داخليًا)، بدلاً من بناء كل وظيفة من جديد."
    },
    {
        "question": "ماذا تعني 'قابلية الإصلاح' (Maintainability) كخاصية للنظام؟",
        "options": [
            "أن النظام لا يتعطل أبداً",
            "سهولة تشخيص وإصلاح الأخطاء أو إجراء تعديلات على النظام",
            "قدرة النظام على إصلاح نفسه تلقائياً",
            "أن النظام يعمل على جميع أنظمة التشغيل"
        ],
        "correctAnswerIndex": 1,
        "explanation": "قابلية الإصلاح هي مقياس لمدى سهولة فهم الكود وتعديله وتحديثه. نظام ذو قابلية إصلاح عالية يكون أقل تكلفة في الصيانة والتطوير على المدى الطويل."
    },
    {
        "question": "في DFD، ما هي القاعدة المتعلقة بتدفق البيانات بين مخزني بيانات (Data Stores)؟",
        "options": [
            "يمكن أن يتدفق البيانات مباشرة بينهما",
            "يجب أن يمر تدفق البيانات عبر عملية (Process)",
            "يجب أن يمر تدفق البيانات عبر كيان خارجي",
            "لا يمكن لمخازن البيانات أن تتصل ببعضها البعض"
        ],
        "correctAnswerIndex": 1,
        "explanation": "من قواعد رسم DFD أن البيانات لا يمكن أن تنتقل مباشرة من مخزن إلى آخر. يجب أن تكون هناك عملية تقوم بقراءة البيانات من مخزن وكتابتها في المخزن الآخر، لأن المخازن هي كيانات سلبية لا تبدأ أي إجراء."
    },
    {
        "question": "الفرق بين النموذج التزايدي (Incremental) والنموذج التكراري (Iterative) هو:",
        "options": [
            "لا يوجد فرق بينهما",
            "التزايدي يسلم أجزاء من الوظائف، بينما التكراري يحسن النظام ككل في كل دورة",
            "التكراري أسرع دائماً من التزايدي",
            "التزايدي لا يتضمن اختباراً"
        ],
        "correctAnswerIndex": 1,
        "explanation": "في النموذج التزايدي، يتم بناء وتسليم أجزاء (زيادات) من النظام بشكل متتالٍ، وكل جزء يضيف وظائف جديدة. في النموذج التكراري، يتم بناء نسخة أولية للنظام بأكمله ثم يتم تحسينها وتنقيتها عبر عدة دورات (تكرارات)."
    },
    {
        "question": "ما هو مصطلح هندسة البرمجيات الذي يعني 'ربط مبادئ الهندسة بالبرمجيات'؟",
        "options": [
            "علم الحاسوب",
            "هندسة البرمجيات",
            "نظم المعلومات",
            "البرمجة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "تم طرح مصطلح هندسة البرمجيات في عام 1968 للتعبير عن الحاجة إلى تطبيق نهج هندسي منظم ومنضبط لتطوير البرمجيات لمواجهة أزمة البرمجيات في ذلك الوقت."
    },
    {
        "question": "ما هو الهدف من 'التسامح مع الأخطاء' (Fault Tolerance)؟",
        "options": [
            "منع حدوث الأخطاء بشكل كامل",
            "تمكين النظام من مواصلة العمل بشكل صحيح على الرغم من وجود أخطاء أو أعطال في بعض مكوناته",
            "إصلاح جميع الأخطاء قبل تسليم البرنامج",
            "تسجيل الأخطاء في ملف خاص"
        ],
        "correctAnswerIndex": 1,
        "explanation": "التسامح مع الأخطاء هو تصميم النظام بطريقة تسمح له بالتعامل مع الأعطال (مثل فشل أحد المكونات) والاستمرار في تقديم الخدمة، غالبًا عن طريق وجود مكونات احتياطية أو آليات للتعافي."
    },
    {
        "question": "أي من الخيارات التالية يمثل مشكلة 'غموض' في متطلب مكتوب باللغة الطبيعية؟",
        "options": [
            "يجب على النظام حساب الضريبة بنسبة 15%",
            "عندما يضغط المستخدم على 'حفظ'، يتم تخزين البيانات في قاعدة البيانات 'Orders'",
            "يجب أن تكون واجهة المستخدم سهلة الاستخدام",
            "يجب ألا يتجاوز طول كلمة المرور 16 حرفًا"
        ],
        "correctAnswerIndex": 2,
        "explanation": "عبارة 'سهلة الاستخدام' هي عبارة غامضة وذاتية، حيث أن ما هو سهل لمستخدم قد يكون صعبًا لآخر. المتطلبات الجيدة يجب أن تكون قابلة للقياس والتحقق بشكل موضوعي."
    },
    {
        "question": "ما هو الدور المزدوج للبرمجيات كما ورد في المحاضرات؟",
        "options": [
            "كونها منتج ووسيلة لإنتاج منتجات أخرى",
            "كونها للأجهزة والحواسيب",
            "كونها مجانية ومدفوعة",
            "كونها مفتوحة المصدر ومغلقة المصدر"
        ],
        "correctAnswerIndex": 0,
        "explanation": "للبرمجيات دور مزدوج: فهي 'منتج' بحد ذاتها (مثل نظام التشغيل أو التطبيق)، وهي أيضًا 'وسيلة' أو أداة تستخدم لإنتاج منتجات برمجية أخرى (مثل المترجمات وبيئات التطوير)."
    },
    {
        "question": "ما هو المصطلح الذي يصف عملية تحديد الكلف والفوائد الفعلية لنظام برمجي مقترح؟",
        "options": [
            "دراسة الجدوى الاقتصادية",
            "دراسة الجدوى الفنية",
            "دراسة الجدوى التشغيلية",
            "تحليل المتطلبات"
        ],
        "correctAnswerIndex": 0,
        "explanation": "دراسة الجدوى الاقتصادية تركز على تقييم ما إذا كانت الفوائد المالية المتوقعة من النظام تبرر تكاليف تطويره وتشغيله، أي تحديد ما إذا كان المشروع مربحاً من الناحية المالية."
    },
    {
        "question": "في مخطط PERT، ما هو 'الزمن الراكد' (Slack Time) لنشاط ما؟",
        "options": [
            "الوقت اللازم لإنجاز النشاط",
            "مقدار الوقت الذي يمكن أن يتأخر فيه نشاط ما دون أن يؤثر على تاريخ انتهاء المشروع",
            "الوقت الذي يستغرقه النشاط في أسوأ الظروف",
            "الوقت الذي يكون فيه النشاط متوقفاً عن العمل"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الزمن الراكد هو مقدار المرونة الزمنية المتاحة لنشاط معين. الأنشطة الواقعة على المسار الحرج يكون زمنها الراكد صفراً، مما يعني أن أي تأخير فيها يؤخر المشروع بأكمله."
    },
    {
        "question": "ما هو الاختبار الذي يقوم به المطورون للتحقق من أن وحدة برمجية معينة (دالة أو كائن) تعمل كما هو متوقع؟",
        "options": [
            "اختبار النظام (System Testing)",
            "اختبار القبول (Acceptance Testing)",
            "اختبار التكامل (Integration Testing)",
            "اختبار الوحدة (Unit Testing)"
        ],
        "correctAnswerIndex": 3,
        "explanation": "اختبار الوحدة هو أول مستوى من مستويات الاختبار، حيث يتم فيه اختبار أصغر أجزاء البرنامج (الوحدات) بشكل معزول للتأكد من صحتها المنطقية قبل دمجها مع الأجزاء الأخرى."
    },
    {
        "question": "أي مما يلي لا يعتبر من خصائص النموذج المبني على التطوير السريع للتطبيقات (RAD)؟",
        "options": [
            "دورة تطوير قصيرة جداً (60-120 يوم)",
            "يعتمد على بناء النظام من مكونات جاهزة",
            "يتطلب مشاركة مكثفة من المستخدمين",
            "مناسب للمشاريع ذات المخاطر التقنية العالية وغير المفهومة"
        ],
        "correctAnswerIndex": 3,
        "explanation": "نموذج RAD غير مناسب للمشاريع التي بها مخاطر تقنية عالية أو التي لا يمكن تقسيمها إلى وحدات نمطية، لأنه يعتمد على تقنيات وأدوات معروفة ومكونات قابلة لإعادة الاستخدام لتحقيق السرعة."
    },
    {
        "question": "ما هو الفرق الأساسي بين DFD (مخطط تدفق البيانات) و Flowchart (مخطط التدفق الانسيابي)؟",
        "options": [
            "DFD يوضح تدفق التحكم، و Flowchart يوضح تدفق البيانات",
            "DFD يوضح تدفق البيانات، و Flowchart يوضح تدفق التحكم والمنطق الإجرائي",
            "لا يوجد فرق جوهري بينهما",
            "DFD يستخدم الدوائر، و Flowchart يستخدم المربعات فقط"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الخلط بينهما شائع. DFD يركز على 'ماذا' يحدث للبيانات وهي تتدفق عبر النظام. أما Flowchart فيركز على 'كيف' تتم المعالجة، حيث يوضح الخطوات والشروط والتفرعات (المنطق الإجرائي) بالتفصيل."
    },
    {
        "question": "ما هي العملية التي يتم فيها ترجمة التصميم إلى صيغة تستطيع الآلة (الكمبيوتر) قراءتها وتنفيذها؟",
        "options": [
            "التصميم الأولي (Predesign)",
            "توليد الشفرة (Code Generation)",
            "تحليل المتطلبات (Requirements Analysis)",
            "كتابة كود أولي (Pseudo code)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "مرحلة توليد الشفرة (أو البرمجة) هي المرحلة التي يتم فيها تحويل مواصفات التصميم إلى كود برمجي فعلي باستخدام لغة برمجة معينة، وهو الكود الذي سيتم ترجمته وتنفيذه بواسطة الكمبيوتر."
    },
    {
        "question": "إذا كان نظام ما متاحًا دائمًا ولكن يفشل بشكل متكرر ويتطلب إصلاحًا سريعًا، كيف يمكن وصف حالته؟",
        "options": [
            "إتاحية عالية وموثوقية عالية",
            "إتاحية منخفضة وموثوقية منخفضة",
            "إتاحية عالية وموثوقية منخفضة",
            "إتاحية منخفضة وموثوقية عالية"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الإتاحية (Availability) تأخذ في الاعتبار زمن الإصلاح. إذا كان الإصلاح سريعًا جدًا، يمكن أن يبقى النظام متاحًا معظم الوقت. لكن الموثوقية (Reliability) تقاس بالزمن بين الأعطال، وبما أنه يفشل بشكل متكرر، فموثوقيته منخفضة."
    },
    {
        "question": "أي مما يلي لا يعتبر من مهام مرحلة استنتاج وتحليل المتطلبات؟",
        "options": [
            "فهم نطاق التطبيق وجمع المتطلبات",
            "تصنيف المتطلبات في مجموعات مترابطة",
            "تفضيل المتطلبات والمفاوضة",
            "كتابة الكود البرمجي التفصيلي"
        ],
        "correctAnswerIndex": 3,
        "explanation": "كتابة الكود البرمجي هي جزء من مرحلة التنفيذ (Implementation) أو التطوير (Development)، والتي تأتي بعد مرحلة تحليل المتطلبات وتصميم النظام."
    },
    {
        "question": "في هندسة البرمجيات، 'الطرق النظامية' (Formal Methods) هي تقنيات لـ:",
        "options": [
            "إدارة فرق العمل",
            "توصيف واختبار الأنظمة باستخدام تدوين رياضي دقيق",
            "تسويق المنتجات البرمجية",
            "التنبؤ بتكلفة المشروع"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الطرق النظامية تستخدم لغات ومفاهيم مبنية على الرياضيات (مثل نظرية المجموعات والمنطق) لتوصيف سلوك النظام بشكل لا لبس فيه، مما يسمح بالتحقق من صحة المواصفات بشكل رياضي."
    },
    {
        "question": "في اختبار الصندوق الأبيض، ما هو 'الطريق الميت' (dead log)؟",
        "options": [
            "حلقة لا نهائية",
            "متغير غير مستخدم",
            "جزء من الكود لا يمكن الوصول إليه أو تنفيذه أبدًا",
            "خطأ في تسجيل الخروج من النظام"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الطريق الميت أو الكود الميت هو جزء من البرنامج لا يمكن الوصول إليه تحت أي ظرف من الظروف. اكتشافه مهم لأنه قد يشير إلى خطأ منطقي أو أن الكود أصبح غير ضروري ويجب إزالته."
    },
    {
        "question": "ما هي الخاصية التي تعكس المدى الذي يمكن به تكييف النظام مع متطلبات جديدة؟",
        "options": [
            "قابلية الإصلاح (Repairability)",
            "الصيانة والتحسين (Maintainability/Evolvability)",
            "التسامح مع الأخطاء (Fault Tolerance)",
            "الموثوقية (Reliability)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "قابلية التحسين أو الصيانة التطورية (Evolvability) هي مقياس لسهولة تعديل النظام وتطويره لإضافة وظائف جديدة أو التكيف مع التغيرات في بيئة العمل، وهي عامل مهم في التكلفة طويلة الأمد للنظام."
    },
    {
        "question": "في DFD، ماذا يمثل الرمز الذي يكون على شكل مستطيل مفتوح من جهتين؟",
        "options": [
            "عملية (Process)",
            "كيان خارجي (External Entity)",
            "مخزن بيانات (Data Store)",
            "تدفق بيانات (Data Flow)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الرمز المكون من خطين متوازيين، أو مستطيل مفتوح من جانب واحد أو كلا الجانبين، يستخدم عادة لتمثيل مخزن البيانات، وهو مكان يتم فيه تخزين البيانات بشكل دائم أو مؤقت داخل النظام."
    },
    {
        "question": "في النموذج التكراري (Iterative Model)، ماذا يحدث في كل دورة (iteration)؟",
        "options": [
            "يتم إضافة وظائف جديدة بالكامل للنظام",
            "يتم تحسين وتطوير نسخة عاملة من النظام بأكمله",
            "يتم كتابة التوثيق فقط",
            "يتم تسليم المنتج النهائي للعميل"
        ],
        "correctAnswerIndex": 1,
        "explanation": "النموذج التكراري يبدأ بنسخة أولية من النظام، وفي كل دورة تالية يتم إعادة العمل على هذه النسخة وتحسينها وإضافة تفاصيل أكثر، وصولاً إلى المنتج النهائي. التركيز على التحسين والتنقيح في كل دورة."
    },
    {
        "question": "ما هو الهدف من عملية توثيق المتطلبات (Requirements Documentation)؟",
        "options": [
            "إنشاء عقد رسمي بين العميل والمطور",
            "تسهيل التواصل بين أعضاء الفريق",
            "تكون أساسًا لمراحل التصميم والاختبار اللاحقة",
            "كل ما سبق صحيح"
        ],
        "correctAnswerIndex": 3,
        "explanation": "وثيقة المتطلبات لها أدوار متعددة؛ فهي تعمل كمرجع متفق عليه بين جميع الأطراف، وتساعد على ضمان فهم مشترك للمطلوب، وتستخدم كأساس للتحقق من صحة النظام في المراحل النهائية."
    },
    {
        "question": "ماذا يعني 'الفشل المسبب للعطب' (Corrupting Failure)؟",
        "options": [
            "فشل يؤدي إلى توقف النظام بالكامل",
            "فشل يؤدي إلى تلف أو تغيير حالة النظام أو بياناته",
            "فشل يحدث بشكل مؤقت فقط",
            "فشل لا يمكن إصلاحه"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الفشل المسبب للعطب هو النوع الخطير من الفشل الذي لا يوقف النظام فحسب، بل يتسبب في إتلاف بياناته أو تركه في حالة داخلية غير متسقة، مما قد يتطلب عمليات استعادة معقدة."
    },
    {
        "question": "ما هي أول خطوة في عملية هندسة المتطلبات؟",
        "options": [
            "توصيف المتطلبات",
            "التحقق من المتطلبات",
            "استنتاج وتحليل المتطلبات",
            "إدارة المتطلبات"
        ],
        "correctAnswerIndex": 2,
        "explanation": "العملية تبدأ باستنتاج (Elicitation) وتحليل المتطلبات، وهي مرحلة جمع المعلومات من أصحاب المصلحة وفهم احتياجاتهم ومجال العمل قبل الانتقال إلى توثيقها والتحقق منها."
    },
    {
        "question": "أي من الخيارات التالية لا يعتبر من سمات البرامج الجيدة؟",
        "options": [
            "قابلية الصيانة (Maintainable)",
            "الكفاءة (Efficient)",
            "التعقيد العالي للكود (High code complexity)",
            "المقبولية (Acceptable)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "البرامج الجيدة يجب أن تكون سهلة الصيانة، فعالة في استخدام الموارد، ومقبولة من قبل مستخدميها. التعقيد العالي للكود عادة ما يكون سمة سلبية لأنه يجعل البرنامج صعب الفهم والتعديل والصيانة."
    },
    {
        "question": "أي مما يلي يصف العلاقة بين السلامة (Safety) والموثوقية (Reliability)؟",
        "options": [
            "هما نفس الشيء تمامًا",
            "النظام الموثوق هو دائمًا نظام آمن",
            "قد يكون النظام غير موثوق (يفشل كثيرًا) ولكنه آمن (فشله لا يسبب ضررًا)",
            "النظام الآمن هو دائمًا نظام موثوق"
        ],
        "correctAnswerIndex": 2,
        "explanation": "يمكن لنظام أن يفشل بشكل متكرر (موثوقية منخفضة) ولكن يتم تصميمه بحيث أن كل حالات الفشل تنقله إلى حالة آمنة (مثل إطفاء جهاز طبي بدلاً من إعطاء جرعة خاطئة). لذلك، الموثوقية لا تضمن السلامة بالضرورة."
    },
    {
        "question": "ما هو الاختبار الذي يركز على التحقق من أن النظام بأكمله ككيان واحد يلبي المواصفات المحددة؟",
        "options": [
            "اختبار الوحدة (Unit Testing)",
            "اختبار التكامل (Integration Testing)",
            "اختبار النظام (System Testing)",
            "اختبار الانحدار (Regression Testing)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "بعد تجميع جميع المكونات واختبار تكاملها، يتم اختبار النظام ككل في مرحلة اختبار النظام. يركز هذا الاختبار على التحقق من المتطلبات الوظيفية وغير الوظيفية للنظام بأكمله."
    },
    {
        "question": "ما هو تعريف 'الهجوم' (Attack) في سياق أمن المعلومات؟",
        "options": [
            "وجود ضعف في النظام",
            "الضرر الناتج عن اختراق",
            "محاولة متعمدة لاستغلال نقطة ضعف في النظام لإحداث ضرر",
            "برنامج حماية من الفيروسات"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الهجوم هو إجراء فعلي ومتعمد يستهدف استغلال ثغرة أمنية (Vulnerability) في النظام بهدف التسبب في ضرر مثل سرقة البيانات أو تعطيل الخدمة."
    },
    {
        "question": "في DFD، هل يمكن لعملية (Process) أن يكون لها مدخلات فقط دون مخرجات؟",
        "options": [
            "نعم، هذا ممكن",
            "لا، تعتبر هذه الحالة خطأ في التصميم (تسمى الثقب الأسود)",
            "نعم، ولكن فقط إذا كانت العملية الأخيرة في النظام",
            "لا، ولكن يمكن أن يكون لها مخرجات فقط دون مدخلات"
        ],
        "correctAnswerIndex": 1,
        "explanation": "من قواعد DFD السليمة أن كل عملية يجب أن يكون لها مدخل واحد على الأقل ومخرج واحد على الأقل. العملية التي لها مدخلات ولا تنتج مخرجات تسمى 'ثقب أسود' (Black Hole)، والعملية التي تنتج مخرجات من لا شيء تسمى 'معجزة' (Miracle)، وكلاهما خطأ في الرسم."
    },
    {
        "question": "ما هو هدف 'النموذج المبني على المخاطر' مثل النموذج الحلزوني؟",
        "options": [
            "تقليل المخاطر عن طريق تحديدها ومعالجتها في وقت مبكر من دورة الحياة",
            "تجاهل المخاطر للتركيز على البرمجة",
            "تسليم المشروع في أسرع وقت ممكن بغض النظر عن المخاطر",
            "تأجيل التعامل مع المخاطر إلى مرحلة الصيانة"
        ],
        "correctAnswerIndex": 0,
        "explanation": "الهدف الرئيسي للنماذج القائمة على المخاطر هو تقليل احتمالية فشل المشروع عن طريق تحديد أكبر المخاطر بشكل منهجي في كل مرحلة وتطوير استراتيجيات للتخفيف منها أو تجنبها."
    },
    {
        "question": "ما هي الخاصية التي تعكس قدرة النظام على التعامل مع مدخلات غير متوقعة أو خاطئة دون أن ينهار؟",
        "options": [
            "المتانة (Robustness)",
            "الكفاءة (Efficiency)",
            "قابلية النقل (Portability)",
            "قابلية التوسع (Scalability)"
        ],
        "correctAnswerIndex": 0,
        "explanation": "المتانة هي مقياس لقدرة النظام على التعامل مع الظروف غير المثالية، مثل المدخلات غير الصحيحة أو فشل المكونات، والاستمرار في العمل أو الفشل بطريقة متوقعة وآمنة."
    },
    {
        "question": "إذا كانت مرحلة تحليل المتطلبات هي المرحلة الأولى من أي مشروع برمجي، فماذا يأتي بعدها مباشرة حسب النموذج الشلالي؟",
        "options": [
            "دراسة الجدوى",
            "التصميم",
            "التنفيذ",
            "الاختبار"
        ],
        "correctAnswerIndex": 1,
        "explanation": "في النموذج الشلالي الكلاسيكي، تتبع المراحل ترتيبًا خطيًا صارمًا. بعد الانتهاء من تحديد وتوثيق المتطلبات بالكامل، تبدأ مرحلة تصميم النظام (System Design)."
    },
    {
        "question": "ما هو المصطلح الذي يصف الأضرار الناجمة عن انعدام الأمن في النظام؟",
        "options": [
            "رفض تقديم الخدمة",
            "انعطاب البرامج أو البيانات",
            "كشف عن معلومات سرية",
            "كل ما سبق صحيح"
        ],
        "correctAnswerIndex": 3,
        "explanation": "انعدام الأمن يمكن أن يؤدي إلى أنواع مختلفة من الأضرار، بما في ذلك هجمات حجب الخدمة، وتلف البيانات، والكشف غير المصرح به عن المعلومات الحساسة."
    },
    {
        "question": "السمات التي يتم وصفها باستخدام Schema في الطرق النظامية Z هي:",
        "options": [
            "السمات الساكنة فقط",
            "السمات المتحركة فقط",
            "السمات الساكنة والمتحركة",
            "سمات الأداء فقط"
        ],
        "correctAnswerIndex": 2,
        "explanation": "تُستخدم مخططات Z (Schemas) لوصف كل من الجوانب الساكنة للنظام (الحالات والعلاقات الثابتة بين المتغيرات) والجوانب الديناميكية (العمليات التي تغير حالة النظام)."
    },
    {
        "question": "ما هي خاصية قابلية البقاء على قيد الحياة للنظام؟",
        "options": [
            "تعكس المدى الذي يمكن به إصلاح النظام في حالة فشل النظام",
            "تعكس المدى الذي يمكن أن يستمر النظام بتقديم الخدمات المطلوبة بينما يتعرض لهجوم ما",
            "تعكس المدى الذي يمكن به تكييف النظام مع أي متطلبات جديدة",
            "كل ما سبق خاطئ"
        ],
        "correctAnswerIndex": 1,
        "explanation": "قابلية البقاء على قيد الحياة (Survivability) هي قدرة النظام على مواصلة تقديم وظائفه الأساسية في مواجهة الهجمات أو الأعطال الكبيرة، مما يجعلها خاصية مهمة للأنظمة الحرجة."
    },
    {
        "question": "ما هو التعريف الأدق للإتاحية (Availability)؟",
        "options": [
            "احتمال تشغيل النظام على مدى فترة زمنية معينة",
            "احتمال وجود النظام في نقطة زمنية محددة وقادر على تقديم الخدمات المطلوبة",
            "قدرة النظام على حماية نفسه ضد الهجمات",
            "زمن إصلاح النظام بعد الفشل"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الإتاحية هي مقياس 'لحظي' لاحتمالية أن يكون النظام جاهزًا للعمل عند الحاجة إليه. يتم حسابها عادةً كنسبة من الوقت الذي يكون فيه النظام قيد التشغيل إلى إجمالي الوقت."
    },
    {
        "question": "ماذا يمثل الرسم البياني لتدفق التحكم (CFG)؟",
        "options": [
            "تدفق البيانات بين مكونات النظام",
            "هيكلية قاعدة البيانات",
            "جميع المسارات الممكنة للتنفيذ عبر برنامج ما",
            "التسلسل الهرمي للمشروع"
        ],
        "correctAnswerIndex": 2,
        "explanation": "مخطط تدفق التحكم هو تمثيل رسومي لجميع المسارات التي يمكن أن يتخذها التنفيذ من خلال مكون برمجي. العقد تمثل التعليمات، والحواف تمثل القفزات أو التدفق المتسلسل."
    },
    {
        "question": "ما هو الفشل الذي يحدث مع كافة المدخلات ويستمر حتى يتم إصلاح الخلل المسبب له؟",
        "options": [
            "الفشل العابر (Transient)",
            "الفشل الدائم (Permanent)",
            "الفشل القابل للاسترداد (Recoverable)",
            "الفشل غير المسبب للعطب (Non-corrupting)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الفشل الدائم هو الذي يتكرر بشكل مستمر ومتوقع مع جميع أنواع المدخلات تقريبًا، وهو عادةً ما يكون ناتجًا عن خلل ثابت في الكود أو عتاد الحاسوب."
    },
    {
        "question": "أي من الخيارات التالية يعتبر من مشاكل اللغة الطبيعية عند كتابة المتطلبات؟",
        "options": [
            "الغموض والإفراط في المرونة",
            "عدم الوضوح وخلط المتطلبات",
            "كل ما سبق صحيح",
            "كل ما سبق خاطئ"
        ],
        "correctAnswerIndex": 2,
        "explanation": "اللغة الطبيعية، على الرغم من سهولتها، تعاني من عدة مشاكل عند استخدامها لتوصيف المتطلبات، مثل الغموض (قابلية التفسير بأكثر من طريقة)، وعدم الدقة، وخلط أنواع مختلفة من المتطلبات معًا."
    },
    {
        "question": "أي من الخصائص التالية يعتبر من خصائص الاعتمادية (Dependability)؟",
        "options": [
            "التسامح مع الأخطاء",
            "قابلية الإصلاح",
            "قابلية الصيانة والتحسين",
            "كل ما سبق صحيح"
        ],
        "correctAnswerIndex": 3,
        "explanation": "الاعتمادية مفهوم واسع يشمل العديد من الخصائص. بالإضافة إلى الأبعاد الرئيسية (الإتاحة، الموثوقية، السلامة، الأمن)، فإنه يشمل أيضًا خصائص مساندة مثل التسامح مع الأخطاء وقابلية الإصلاح والصيانة."
    },
    {
        "question": "ما هو الهدف من عملية Verification (التحقق) في هندسة البرمجيات؟",
        "options": [
            "التأكد من أن النظام يلبي احتياجات المستخدم",
            "التأكد من أن النظام تم بناؤه بشكل صحيح وفقًا للمواصفات",
            "اختبار النظام من قبل المستخدم النهائي",
            "تعديل النظام بعد إصداره"
        ],
        "correctAnswerIndex": 1,
        "explanation": "التحقق (Verification) يجيب على سؤال: 'هل نبني المنتج بشكل صحيح؟'. وهو يركز على فحص العمليات والمخرجات الداخلية للتأكد من خلوها من الأخطاء ومطابقتها للمواصفات المحددة."
    },
    {
        "question": "إذا كان متطلب الأداء ينص على 'معالجة 100 معاملة في الثانية'، فهذا يعتبر متطلب:",
        "options": [
            "وظيفي",
            "غير وظيفي",
            "تصميم",
            "مستخدم"
        ],
        "correctAnswerIndex": 1,
        "explanation": "هذا المتطلب لا يصف وظيفة بحد ذاتها، بل يضع قيدًا على أداء النظام (السرعة والقدرة الاستيعابية). المتطلبات المتعلقة بالأداء، السرعة، الموثوقية، والأمان هي دائمًا متطلبات غير وظيفية."
    },
    {
        "question": "ماذا تعني 'هندسة المتطلبات' (Requirements Engineering)؟",
        "options": [
            "عملية كتابة الكود البرمجي",
            "عملية تصميم قواعد البيانات",
            "عملية تحديد وفهم وتوثيق ما هو مطلوب من النظام",
            "عملية اختبار النظام بعد اكتماله"
        ],
        "correctAnswerIndex": 2,
        "explanation": "هندسة المتطلبات هي عملية منهجية تشمل جميع الأنشطة المتعلقة بالمتطلبات، بدءًا من استنباطها من أصحاب المصلحة، وتحليلها، وتوثيقها، والتحقق من صحتها، وإدارتها طوال دورة حياة المشروع."
    },
    {
        "question": "ما هو عيب النموذج الشلالي الرئيسي؟",
        "options": [
            "بساطته وسهولة فهمه",
            "صعوبة التعامل مع التغييرات في المتطلبات بعد بدء المشروع",
            "اعتماده على مراحل واضحة",
            "مناسبته للمشاريع الصغيرة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "العيب الأساسي للنموذج الشلالي هو عدم مرونته. نظرًا لطبيعته الخطية، فإن العودة إلى مرحلة سابقة (مثل المتطلبات) بعد الوصول إلى مرحلة متقدمة (مثل البرمجة) لإجراء تغييرات يعد أمرًا مكلفًا ومعقدًا للغاية."
    },
    {
        "question": "ما هو الفرق بين 'الخطأ' (Error) و 'الفشل' (Failure)؟",
        "options": [
            "لا يوجد فرق",
            "الخطأ هو حالة داخلية غير صحيحة، والفشل هو انحراف خارجي ملحوظ عن السلوك المتوقع",
            "الفشل هو حالة داخلية غير صحيحة، والخطأ هو انحراف خارجي ملحوظ",
            "الخطأ يحدث في البرمجيات والفشل يحدث في الأجهزة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الخلل (Fault) في الكود قد يؤدي إلى خطأ (Error) وهو حالة غير صحيحة لمتغير أو جزء من ذاكرة النظام. إذا انتشر هذا الخطأ ووصل إلى مخرجات النظام وتسبب في سلوك غير صحيح، يسمى ذلك فشلاً (Failure)."
    },
    {
        "question": "أي من الطرق التالية تستخدم لتوصيف النظام باستخدام نماذج رياضية مثل المجموعات والسالسل؟",
        "options": [
            "الطرق القائمة على النماذج (Model-Based)",
            "الطرق الجبرية (Algebraic)",
            "الطرق الاحتمالية (Probabilistic)",
            "الطرق التجريبية (Empirical)"
        ],
        "correctAnswerIndex": 0,
        "explanation": "الطرق القائمة على النماذج، مثل لغة Z و VDM، تعتمد على بناء نموذج رياضي مجرد لحالة النظام (State)، ثم وصف العمليات كتغييرات على هذا النموذج، مما يسمح بتحليل دقيق للسلوك."
    },
    {
        "question": "ما هو الغرض من 'اختبار الانحدار' (Regression Testing)؟",
        "options": [
            "اختبار وظيفة جديدة تمت إضافتها",
            "التأكد من أن التغييرات الجديدة أو إصلاحات الأخطاء لم تؤثر سلبًا على الوظائف الموجودة سابقًا",
            "اختبار أداء النظام",
            "اختبار واجهة المستخدم"
        ],
        "correctAnswerIndex": 1,
        "explanation": "يتم إجراء اختبار الانحدار بعد كل تعديل على الكود للتأكد من أن الوظائف التي كانت تعمل بشكل صحيح في السابق لا تزال تعمل كما هي ولم تتأثر بالتغيير الجديد بشكل غير مقصود."
    },
    {
        "question": "في DFD، هل يمكن لتدفق البيانات أن يبدأ من عملية ويتجه إلى نفس العملية؟",
        "options": [
            "نعم، هذا مسموح به دائمًا",
            "لا، هذا غير منطقي ويعتبر خطأ في الرسم",
            "نعم، ولكن فقط إذا كانت العملية تخزن البيانات مؤقتًا",
            "نعم، ولكن فقط في المستوى صفر"
        ],
        "correctAnswerIndex": 1,
        "explanation": "تدفق البيانات يجب أن يمثل حركة البيانات بين مكونات مختلفة (عملية إلى أخرى، عملية إلى مخزن، كيان إلى عملية، إلخ). تدفق البيانات من عملية إلى نفسها لا يمثل حركة بيانات مفيدة ويعتبر خطأً في بناء المخطط."
    },
    {
        "question": "ما هو المفهوم الذي يصف أن متطلبات التسليم والمتطلبات القانونية هي أنواع من؟",
        "options": [
            "المتطلبات الوظيفية",
            "المتطلبات غير الوظيفية",
            "متطلبات المستخدم",
            "متطلبات التصميم"
        ],
        "correctAnswerIndex": 1,
        "explanation": "متطلبات التسليم (كيف ومتى يتم تسليم المنتج) والمتطلبات القانونية (القيود التي تفرضها القوانين) كلاهما يصفان قيودًا على النظام أو عملية تطويره، وليس وظائف أساسية، وبالتالي فهما من المتطلبات غير الوظيفية."
    },
    {
        "question": "إذا كان متوسط الزمن بين الأعطال (MTTF) لنظام هو 500 ساعة، ماذا يعني ذلك؟",
        "options": [
            "أن النظام سيفشل كل 500 ساعة بالضبط",
            "أن متوسط عمر النظام قبل أن يفشل هو 500 ساعة من التشغيل",
            "أن إصلاح النظام يستغرق 500 ساعة",
            "أن النظام متاح بنسبة 500%"
        ],
        "correctAnswerIndex": 1,
        "explanation": "MTTF (Mean Time To Failure) هو مقياس للموثوقية، وهو يمثل متوسط الفترة الزمنية التي يعمل فيها النظام بشكل صحيح قبل أن يواجه أول فشل (أو بين حالات الفشل للأنظمة التي يتم إصلاحها)."
    },
    {
        "question": "أي من النماذج التالية يجمع بين الطبيعة التكرارية للنمذجة الأولية والجوانب النظامية للنموذج الشلالي؟",
        "options": [
            "نموذج V",
            "نموذج تجميع المكونات",
            "النموذج الحلزوني",
            "النموذج التزايدي"
        ],
        "correctAnswerIndex": 2,
        "explanation": "النموذج الحلزوني يجمع بين أفضل ما في النموذجين: يستخدم التكرار والنمذجة الأولية لتقليل المخاطر المتعلقة بالمتطلبات، ولكنه يتبع أيضًا نهجًا منظمًا ومتسلسلاً (مثل الشلالي) داخل كل دورة."
    },
    {
        "question": "في DFD، ما هو الكيان الذي يمكن تقسيمه إلى عمليات فرعية في مستوى أدنى؟",
        "options": [
            "الكيان الخارجي (External Entity)",
            "مخزن البيانات (Data Store)",
            "العملية (Process)",
            "تدفق البيانات (Data Flow)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "العملية (Process) هي الكيان الوحيد في DFD الذي يمكن تفصيله أو 'تفجيره' إلى مخطط DFD جديد في مستوى أدنى يوضح مكوناته الداخلية من عمليات فرعية ومخازن بيانات."
    },
    {
        "question": "متطلب 'يجب أن يتمكن النظام من معالجة مدفوعات بطاقات فيزا وماستركارد' هو مثال على:",
        "options": [
            "متطلب وظيفي",
            "متطلب أداء",
            "متطلب أمان",
            "متطلب قابلية استخدام"
        ],
        "correctAnswerIndex": 0,
        "explanation": "هذا المتطلب يصف خدمة أو وظيفة محددة يجب أن يقدمها النظام (وهي معالجة أنواع معينة من المدفوعات). لذلك، هو متطلب وظيفي."
    },
    {
        "question": "ماذا يعني مصطلح 'تجريد المتطلبات' (Requirements Abstraction)؟",
        "options": [
            "جعل المتطلبات غامضة",
            "وصف المتطلبات على مستوى عالٍ دون الخوض في تفاصيل التنفيذ",
            "حذف المتطلبات غير المهمة",
            "ترجمة المتطلبات إلى كود"
        ],
        "correctAnswerIndex": 1,
        "explanation": "التجريد هو مبدأ أساسي في الهندسة، ويعني التركيز على الجوانب الأساسية للمشكلة (ما هو المطلوب؟) وتجاهل التفاصيل غير الضرورية في مرحلة معينة (كيف سيتم التنفيذ؟)."
    },
    {
        "question": "أي من الأنشطة التالية لا يندرج تحت 'عملية تطوير البرمجيات' (Development)؟",
        "options": [
            "التصميم (Design)",
            "البرمجة (Coding)",
            "التحقق من صحة المتطلبات (Requirements Validation)",
            "كل ما سبق يندرج تحتها"
        ],
        "correctAnswerIndex": 2,
        "explanation": "التحقق من صحة المتطلبات هو جزء من 'هندسة المتطلبات'. أما عملية التطوير فتشمل بشكل أساسي التصميم (تحويل المتطلبات إلى مخططات) والتنفيذ (تحويل التصميم إلى كود)."
    },
    {
        "question": "ما هي الخطوة التي تلي مرحلة 'التصميم' في النموذج الشلالي؟",
        "options": [
            "تحليل المتطلبات",
            "التنفيذ (البرمجة)",
            "الاختبار",
            "الصيانة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "وفقًا للتسلسل الخطي للنموذج الشلالي، بعد الانتهاء من تصميم بنية النظام ومكوناته، تبدأ مرحلة التنفيذ أو البرمجة، حيث يتم كتابة الكود الفعلي بناءً على مواصفات التصميم."
    },
    {
        "question": "ما هي السمة التي تعكس مدى سهولة نقل البرنامج ليعمل على بيئة أجهزة أو أنظمة تشغيل مختلفة؟",
        "options": [
            "قابلية النقل (Portability)",
            "قابلية التوسع (Scalability)",
            "المتانة (Robustness)",
            "الكفاءة (Efficiency)"
        ],
        "correctAnswerIndex": 0,
        "explanation": "قابلية النقل هي متطلب غير وظيفي يحدد مدى سهولة تكييف البرنامج للعمل في بيئات حوسبة مختلفة. الأنظمة ذات قابلية النقل العالية تقلل من تكلفة الانتقال إلى منصات جديدة في المستقبل."
    },
    {
        "question": "ما هو الغرض من استخدام 'قائمة التحقق' (Checklist) أثناء مراجعات الكود؟",
        "options": [
            "تسريع عملية المراجعة بتجاهل التفاصيل",
            "توفير مجموعة منظمة من النقاط والمعايير لفحص الكود بشكل منهجي",
            "تحديد من هو أفضل مبرمج في الفريق",
            "كتابة التعليقات في الكود"
        ],
        "correctAnswerIndex": 1,
        "explanation": "قوائم التحقق تساعد في جعل عمليات المراجعة (للكود أو التصميم أو المتطلبات) أكثر فعالية وتنظيمًا، من خلال تذكير المراجعين بالبحث عن أنواع شائعة من الأخطاء والتأكد من الالتزام بالمعايير المحددة."
    },
    {
        "question": "أي مما يلي لا يعتبر من تقنيات استنباط المتطلبات؟",
        "options": [
            "المقابلات (Interviews)",
            "تحليل شجرة الخطأ (Fault Tree Analysis)",
            "العصف الذهني (Brainstorming)",
            "دراسة الوثائق الحالية (Document Analysis)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "تحليل شجرة الخطأ هو تقنية تستخدم في تحليل المخاطر والسلامة لتحديد أسباب الفشل، وليس لجمع متطلبات المستخدم الأولية. أما الخيارات الأخرى فهي تقنيات شائعة لجمع وفهم المتطلبات."
    },
    {
        "question": "في النموذج التزايدي، كيف يتم تطوير النظام؟",
        "options": [
            "يتم تطوير النظام بأكمله مرة واحدة",
            "يتم بناء سلسلة من الإصدارات (الزيادات)، كل منها يضيف جزءًا من الوظائف المطلوبة",
            "يتم التركيز على إصلاح الأخطاء فقط",
            "يتم بناء نموذج أولي ثم التخلص منه"
        ],
        "correctAnswerIndex": 1,
        "explanation": "النموذج التزايدي يقسم عملية التطوير إلى أجزاء صغيرة قابلة للإدارة تسمى 'زيادات' (Increments). يتم تصميم وبناء واختبار كل زيادة على حدة، ثم تسليمها للعميل، مما يسمح بالحصول على منتج عامل جزئيًا في وقت مبكر."
    },
    {
        "question": "ماذا يعني 'توصيف النظام' (System Specification)؟",
        "options": [
            "خطة المشروع",
            "الوثيقة التي تصف بالتفصيل ما يجب على النظام أن يفعله والقيود المفروضة عليه",
            "دليل المستخدم",
            "الكود المصدري للبرنامج"
        ],
        "correctAnswerIndex": 1,
        "explanation": "وثيقة توصيف النظام (أو مواصفات المتطلبات) هي المخرج الرئيسي لعملية هندسة المتطلبات. وهي تصف بدقة ووضوح جميع المتطلبات الوظيفية وغير الوظيفية للنظام وتعمل كمرجع لجميع مراحل التطوير اللاحقة."
    },
    {
        "question": "أي من الخيارات التالية يعتبر من ميزات استخدام الطرق النظامية (Formal Methods)؟",
        "options": [
            "سهولة فهمها من قبل جميع العملاء",
            "تقليل الغموض في المواصفات والسماح بالتحليل الرياضي الدقيق",
            "انخفاض التكلفة الأولية للمشروع",
            "سرعة التطوير الفائقة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الميزة الرئيسية للطرق النظامية هي قدرتها على إنتاج مواصفات دقيقة وغير غامضة. هذا الوضوح يقلل من الأخطاء في المراحل اللاحقة ويسمح بإثبات صحة بعض خصائص النظام رياضيًا، وهو أمر حيوي للأنظمة الحرجة."
    },
    {
        "question": "ما هو الفرق الرئيسي بين 'متطلبات المستخدم' (User Requirements) و'متطلبات النظام' (System Requirements)؟",
        "options": [
            "لا يوجد فرق بينهما",
            "متطلبات المستخدم مكتوبة للمطورين، ومتطلبات النظام مكتوبة للمستخدمين",
            "متطلبات المستخدم عالية المستوى ومكتوبة بلغة طبيعية، ومتطلبات النظام أكثر تفصيلاً وتقنية",
            "متطلبات المستخدم وظيفية، ومتطلبات النظام غير وظيفية"
        ],
        "correctAnswerIndex": 2,
        "explanation": "متطلبات المستخدم تصف أهداف المستخدم وما يمكنه فعله بالنظام بلغة بسيطة. أما متطلبات النظام فهي وثيقة أكثر تفصيلاً تستخدم كأساس للتصميم، وتصف وظائف النظام وقيوده بدقة للمطورين والمختبرين."
    },
    {
        "question": "في أي مرحلة من دورة حياة البرمجيات يتم التركيز على 'كيف' سيقوم النظام بتحقيق المتطلبات؟",
        "options": [
            "تحليل المتطلبات",
            "التصميم",
            "الاختبار",
            "التخطيط"
        ],
        "correctAnswerIndex": 1,
        "explanation": "مرحلة تحليل المتطلبات تركز على 'ماذا' يجب على النظام فعله. أما مرحلة التصميم، فهي التي يتم فيها تحديد 'كيف' سيتم بناء النظام، من خلال تحديد بنيته، مكوناته، الخوارزميات، وهيكلية البيانات."
    },
    {
        "question": "في تقنية PERT، ما هي الأنشطة التي يكون لها 'زمن راكد' (Slack Time) يساوي صفر؟",
        "options": [
            "جميع أنشطة المشروع",
            "الأنشطة الموجودة على المسار الحرج فقط",
            "أسهل الأنشطة في المشروع",
            "الأنشطة التي لا تعتمد على أي نشاط آخر"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الأنشطة على المسار الحرج ليس لديها أي مرونة زمنية. أي تأخير في هذه الأنشطة سيؤخر المشروع بأكمله. لذلك، فإن الزمن الراكد لها (الفرق بين أبكر وأآخر وقت للبدء) يكون صفرًا."
    },
    {
        "question": "ما هو الهدف من 'التحليل الساكن' (Static Analysis) للكود؟",
        "options": [
            "فحص الكود بحثًا عن الأخطاء المحتملة دون تشغيله فعليًا",
            "قياس سرعة تنفيذ الكود",
            "اختبار الكود بمدخلات ومخرجات حقيقية",
            "مراقبة استخدام الذاكرة أثناء تشغيل البرنامج"
        ],
        "correctAnswerIndex": 0,
        "explanation": "التحليل الساكن يتم عن طريق أدوات تفحص الكود المصدري مباشرةً للبحث عن أنماط خاطئة، أو ثغرات أمنية، أو عدم التزام بمعايير البرمجة، كل ذلك دون الحاجة إلى تنفيذ البرنامج، على عكس التحليل الديناميكي (الاختبار)."
    },
    {
        "question": "ما هو نوع المتطلب الذي يحدد معايير أو طرق تطوير يجب على الفريق الالتزام بها؟",
        "options": [
            "متطلب منتج (Product Requirement)",
            "متطلب تنظيمي (Organizational Requirement)",
            "متطلب خارجي (External Requirement)",
            "متطلب وظيفي (Functional Requirement)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "المتطلبات التنظيمية هي متطلبات غير وظيفية تنشأ من سياسات ومعايير المؤسسة أو العميل، مثل ضرورة استخدام بيئة تطوير معينة، أو اتباع عملية توثيق محددة."
    },
    {
        "question": "ما هي السمة التي يجب أن تتوفر في المتطلبات لتكون قابلة للاختبار؟",
        "options": [
            "الغموض",
            "التجريد العالي",
            "القابلية للتحقق (Verifiability)",
            "المرونة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "لكي يكون المتطلب جيدًا، يجب أن يكون قابلاً للتحقق بشكل موضوعي. هذا يعني أنه يجب أن يكون من الممكن تصميم اختبار أو إجراء فحص يثبت بشكل قاطع ما إذا كان النظام يحقق هذا المتطلب أم لا."
    },
    {
        "question": "ما هو العيب الرئيسي لنموذج النمذجة الأولية (Prototyping)؟",
        "options": [
            "لا يشرك المستخدم في العملية",
            "قد يتسرع المطورون في تسليم النموذج الأولي كمنتج نهائي دون الاهتمام بالجودة والهيكلية",
            "بطيء جدًا في إظهار النتائج",
            "لا يتعامل مع المتطلبات غير الواضحة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "أحد المخاطر الرئيسية لهذا النموذج هو أن العميل قد يرى النموذج الأولي العامل ويعتقد أن المنتج شبه جاهز، مما يضغط على المطورين لتحويله إلى منتج نهائي بسرعة، متجاوزين اعتبارات الجودة والأداء والصيانة."
    },
    {
        "question": "في DFD، هل يمكن لمخزن بيانات (Data Store) أن يتصل مباشرة بكيان خارجي (External Entity)؟",
        "options": [
            "نعم، هذا شائع",
            "لا، يجب أن يمر تدفق البيانات عبر عملية (Process) داخل النظام",
            "نعم، ولكن فقط إذا كان الكيان الخارجي هو مدير النظام",
            "نعم، ولكن فقط لعمليات القراءة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "لا يمكن لكيان خارجي الوصول مباشرة إلى مخازن البيانات الداخلية. يجب أن تكون هناك عملية تعمل كوسيط، تستقبل الطلب من الكيان الخارجي ثم تقوم هي بالوصول إلى مخزن البيانات."
    },
    {
        "question": "أي من الأنشطة التالية هو جزء من عملية المصادقة (Validation)؟",
        "options": [
            "مراجعة الكود (Code Review)",
            "اختبار الوحدة (Unit Testing)",
            "اختبار قبول المستخدم (User Acceptance Testing)",
            "التحليل الساكن (Static Analysis)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "المصادقة (Validation) تتحقق مما إذا كان المنتج يلبي احتياجات العمل والعميل. اختبار قبول المستخدم هو مثال رئيسي على ذلك، حيث يقوم المستخدمون أنفسهم بالتحقق من أن النظام يفعل ما يريدونه."
    },
    {
        "question": "لماذا تعتبر المتطلبات غير الوظيفية حرجة في بعض الأحيان أكثر من المتطلبات الوظيفية؟",
        "options": [
            "لأنها أسهل في التنفيذ",
            "لأنها تؤثر على النظام بأكمله، وفشلها قد يجعل النظام غير قابل للاستخدام",
            "لأن المستخدمين لا يهتمون بها",
            "لأنها لا تحتاج إلى اختبار"
        ],
        "correctAnswerIndex": 1,
        "explanation": "إذا فشل النظام في تلبية متطلب غير وظيفي حاسم (مثل الأمان أو الأداء)، فقد يصبح النظام بأكمله عديم الفائدة، حتى لو كانت جميع وظائفه تعمل بشكل صحيح. على سبيل المثال, نظام بنكي بطيء جدًا أو غير آمن لن يستخدمه أحد."
    },
    {
        "question": "ما هو المبدأ الأساسي وراء نموذج (V-Model) لتطوير البرمجيات؟",
        "options": [
            "تطوير البرمجيات في دورات قصيرة",
            "ربط كل مرحلة من مراحل التطوير بمرحلة اختبار مقابلة لها",
            "التخلص من مرحلة التصميم",
            "التركيز على إعادة استخدام المكونات"
        ],
        "correctAnswerIndex": 1,
        "explanation": "نموذج V هو امتداد للنموذج الشلالي، ويؤكد على العلاقة بين كل مرحلة من مراحل التطوير ونشاط التحقق والمصادقة المقابل لها. على سبيل المثال، يتم تصميم اختبارات القبول أثناء مرحلة تحليل المتطلبات، ويتم تصميم اختبارات النظام أثناء مرحلة التصميم المعماري."
    },
    {
        "question": "ماذا يمثل حدوث 'تعارض' (Conflict) بين المتطلبات؟",
        "options": [
            "أن جميع المتطلبات واضحة",
            "أن متطلبين أو أكثر لا يمكن تحقيقهما معًا في نفس الوقت",
            "أن المتطلبات مكتوبة بلغة برمجة",
            "أن المتطلبات تم توثيقها بالكامل"
        ],
        "correctAnswerIndex": 1,
        "explanation": "يحدث تعارض عندما يكون تحقيق أحد المتطلبات يتعارض مع تحقيق متطلب آخر. على سبيل المثال، متطلب أمان عالي جدًا (مثل تشفير معقد) قد يتعارض مع متطلب أداء عالٍ جدًا (استجابة سريعة). وحل هذه التعارضات جزء من هندسة المتطلبات."
    },
    {
        "question": "أي من الخصائص التالية ليست من خصائص 'مخطط السياق' (Context Diagram) في DFD؟",
        "options": [
            "يمثل النظام كعملية واحدة",
            "يظهر الكيانات الخارجية التي يتفاعل معها النظام",
            "يظهر مخازن البيانات الداخلية للنظام",
            "يظهر تدفقات البيانات الرئيسية من وإلى النظام"
        ],
        "correctAnswerIndex": 2,
        "explanation": "مخطط السياق هو نظرة من الخارج على النظام. إنه يظهر حدود النظام وتفاعلاته مع البيئة، ولكنه لا يظهر أي تفاصيل داخلية مثل العمليات الفرعية أو مخازن البيانات. هذه التفاصيل تظهر في المستويات الأدنى (مثل Level-0 DFD)."
    },
    {
        "question": "ما هو الهدف من 'إدارة التغيير' (Change Management) في سياق المتطلبات؟",
        "options": [
            "رفض جميع التغييرات المقترحة على المتطلبات",
            "قبول جميع التغييرات المقترحة على الفور",
            "وجود عملية منظمة لتحليل، وتقييم، والموافقة على التغييرات في المتطلبات",
            "تغيير المتطلبات بشكل عشوائي"
        ],
        "correctAnswerIndex": 2,
        "explanation": "المتطلبات تتغير حتمًا. إدارة التغيير تهدف إلى التحكم في هذه العملية عن طريق تقييم تأثير كل تغيير مقترح على الجدول الزمني والتكلفة والجودة قبل اتخاذ قرار بتنفيذه، لضمان عدم حدوث فوضى في المشروع."
    },
    {
        "question": "أي من الخيارات التالية يصف بشكل أفضل 'المخاطر التشغيلية' (Operational Risk)؟",
        "options": [
            "خطر تجاوز الميزانية",
            "خطر عدم توفر التكنولوجيا المطلوبة",
            "خطر عدم قبول المستخدمين للنظام أو عدم قدرتهم على استخدامه بفعالية",
            "خطر فشل أحد مكونات الأجهزة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "المخاطر التشغيلية تتعلق بكيفية ملاءمة النظام لبيئة العمل الفعلية. وهي تشمل مخاطر مثل مقاومة الموظفين للتغيير، أو الحاجة إلى تدريب مكثف، أو أن النظام يعطل سير العمل الحالي بدلاً من تحسينه."
    },
    {
        "question": "ما هو ناتج عملية فشل في نظام المهمات الحرجة (Mission-critical system)؟",
        "options": [
            "خسائر بشرية فقط",
            "خسائر اقتصادية وعدم تحقيق الهدف المنشود",
            "خسائر اقتصادية كبيرة فقط",
            "توقف النظام دون أي عواقب"
        ],
        "correctAnswerIndex": 1,
        "explanation": "أنظمة المهمات الحرجة هي التي يؤدي فشلها إلى فشل المهمة التي صممت من أجلها، مما يترتب عليه عادة خسائر مالية كبيرة أو عدم تحقيق أهداف استراتيجية (مثل فشل مهمة فضائية أو نظام تداول مالي)."
    },
    {
        "question": "في DFD، هل يمكن أن يكون هناك تدفق بيانات من مخزن بيانات إلى مخزن بيانات آخر مباشرة؟",
        "options": [
            "نعم، هذا مسموح به",
            "لا، يجب أن يمر تدفق البيانات عبر عملية",
            "نعم، ولكن فقط إذا كانا من نفس النوع",
            "نعم، ولكن فقط في مخطط المستوى صفر"
        ],
        "correctAnswerIndex": 1,
        "explanation": "من قواعد مخططات تدفق البيانات (DFD)، لا يمكن للبيانات أن تتدفق مباشرة بين مخزني بيانات. يجب أن تكون هناك عملية تقوم بقراءة البيانات من المخزن الأول ثم كتابتها في المخزن الثاني، لأن المخازن هي كيانات سلبية."
    },
    {
        "question": "عندما يتم اكتشاف متغير تم تعريفه ولكنه لم يُستخدم أبداً في الكود، فهذا مثال على مشكلة تسمى:",
        "options": [
            "حلقة غير منتهية (liveness loop)",
            "طريق ميت (dead log)",
            "متغير غير حي (liveness variable)",
            "تسرب ذاكرة (memory leak)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "في سياق اختبار الصندوق الأبيض، يُطلق على المتغير الذي يتم الإعلان عنه وحجز مساحة له في الذاكرة ولكن لا يتم استخدامه لاحقًا في أي عملية اسم 'متغير غير حي' (أو متغير ميت). اكتشافه مهم لتحسين الكود وإزالة الموارد غير الضرورية."
    },
    {
        "question": "ما هي الميزة الرئيسية للنموذج التزايدي (Incremental Model)؟",
        "options": [
            "يتطلب معرفة كاملة بالمتطلبات منذ البداية",
            "لا يحتاج إلى اختبار",
            "يسمح بتسليم نسخة عاملة جزئية من المنتج في وقت مبكر",
            "هو الأبطأ بين جميع النماذج"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الميزة الكبرى للنموذج التزايدي هي أنه يقدم قيمة للمستخدم بشكل مبكر. كل 'زيادة' (increment) هي جزء عامل من البرنامج، مما يسمح للعميل بالبدء في استخدام أجزاء من النظام والحصول على تغذية راجعة مبكرة."
    },
    {
        "question": "أي من الخيارات التالية يصف بشكل أفضل 'قابلية التوسع' (Scalability) كمتطلب غير وظيفي؟",
        "options": [
            "قدرة النظام على العمل على أنظمة تشغيل مختلفة",
            "قدرة النظام على التعامل مع زيادة في حجم العمل (مثل عدد المستخدمين أو البيانات) بكفاءة",
            "سهولة إصلاح الأخطاء في النظام",
            "سرعة استجابة النظام"
        ],
        "correctAnswerIndex": 1,
        "explanation": "قابلية التوسع هي قدرة النظام على النمو والتكيف للتعامل مع أعباء عمل متزايدة دون تدهور كبير في الأداء. وهو متطلب غير وظيفي حاسم للأنظمة التي من المتوقع أن ينمو استخدامها بمرور الوقت."
    },
    {
        "question": "أي نوع من 'التحقق والمصادقة' (V&V) يهدف إلى إظهار أن البرنامج يتوافق مع مواصفاته؟",
        "options": [
            "التحقق (Verification)",
            "المصادقة (Validation)",
            "الاختبار الديناميكي (Dynamic testing)",
            "مراجعات الكود (Code reviews)"
        ],
        "correctAnswerIndex": 0,
        "explanation": "التحقق (Verification) هو مجموعة من الأنشطة التي تضمن أن البرمجية تتوافق مع مواصفاتها المحددة. إنه يجيب على سؤال 'هل نبني المنتج بشكل صحيح؟' ويتضمن أنشطة مثل المراجعات والتحليل الساكن."
    },
    {
        "question": "ماذا يمثل الرمز الدائري أو البيضاوي في مخطط تدفق البيانات (DFD)؟",
        "options": [
            "مخزن بيانات",
            "كيان خارجي",
            "عملية (Process)",
            "تدفق بيانات"
        ],
        "correctAnswerIndex": 2,
        "explanation": "في معظم ترميزات DFD، يتم استخدام الدائرة أو المستطيل ذي الحواف الدائرية لتمثيل 'العملية'، وهي أي جزء من النظام يقوم بتحويل المدخلات إلى مخرجات."
    },
    {
        "question": "ما هو الهدف من 'هندسة البرمجيات'؟",
        "options": [
            "بناء برامج بأي طريقة ممكنة",
            "تطبيق نهج منظم ومنضبط وقابل للقياس لتطوير وتشغيل وصيانة البرمجيات",
            "التركيز فقط على كتابة أسرع كود",
            "تصميم الأجهزة فقط"
        ],
        "correctAnswerIndex": 1,
        "explanation": "تهدف هندسة البرمجيات إلى تجاوز البرمجة العشوائية وتطبيق مبادئ هندسية راسخة لإنتاج برمجيات عالية الجودة، يمكن الاعتماد عليها، وصيانتها بسهولة، وذلك ضمن الميزانية والجدول الزمني المحددين."
    },
    {
        "question": "متطلب 'يجب أن يكون الوصول إلى بيانات المرضى مقتصراً على الأطباء المصرح لهم فقط' هو مثال على متطلب:",
        "options": [
            "أداء",
            "أمان",
            "قابلية استخدام",
            "وظيفي"
        ],
        "correctAnswerIndex": 1,
        "explanation": "هذا المتطلب يضع قيدًا على النظام يتعلق بحماية البيانات من الوصول غير المصرح به، وهو جوهر متطلبات الأمان (Security)، والتي هي نوع من المتطلبات غير الوظيفية."
    },
    {
        "question": "ما هي الخطوة التي تلي 'جمع المتطلبات' في عملية هندسة المتطلبات؟",
        "options": [
            "التصميم",
            "الاختبار",
            "التوصيف (Specification) والتوثيق",
            "البرمجة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "بعد جمع المتطلبات من خلال تقنيات مثل المقابلات وورش العمل، يجب تحليلها وتنظيمها ثم توثيقها بشكل واضح ودقيق في وثيقة مواصفات المتطلبات (SRS)."
    },
    {
        "question": "ما هو 'اختبار النظام' (System Testing)؟",
        "options": [
            "اختبار مكونات فردية من البرنامج",
            "اختبار تفاعل المكونات مع بعضها البعض",
            "اختبار النظام بأكمله ككيان واحد متكامل مقابل متطلباته الأصلية",
            "اختبار يتم بواسطة المستخدم النهائي"
        ],
        "correctAnswerIndex": 2,
        "explanation": "بعد الانتهاء من اختبار الوحدات واختبار التكامل، يتم اختبار النظام بأكمله. هذه المرحلة تتحقق من أن النظام ككل يلبي المتطلبات الوظيفية وغير الوظيفية المحددة في وثيقة المواصفات."
    }
]
