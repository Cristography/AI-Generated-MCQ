[
    {
        "question": "ما هي الخاصية الأساسية للأبجدية (Alphabet) في اللغات الصورية؟",
        "options": [
            "أن تكون مجموعة غير منتهية من الرموز",
            "أن تكون مجموعة منتهية وغير خالية من الرموز",
            "أنها تحتوي دائماً على السلسلة الفارغة (ε)",
            "أنها تتكون من سلاسل بدلاً من رموز فردية"
        ],
        "correctAnswerIndex": 1,
        "explanation": "بحسب التعريف الأساسي، الأبجدية (Σ) هي مجموعة منتهية (finite) وغير خالية (non-empty) من الرموز. السلسلة الفارغة (ε) ليست رمزاً في الأبجدية بحد ذاتها."
    },
    {
        "question": "ماذا يمثل إغلاق عملية الوصل (Kleene Closure) A* على أبجدية A؟",
        "options": [
            "مجموعة كل السلاسل الممكنة ذات الطول الموجب فقط",
            "مجموعة كل السلاسل الممكنة بما فيها السلسلة الفارغة",
            "مجموعة السلاسل التي تتكرر فيها الرموز مرتين على الأقل",
            "مجموعة كل الأبجديات الجزئية من A"
        ],
        "correctAnswerIndex": 1,
        "explanation": "إغلاق كلين A* يمثل مجموعة كل السلاسل التي يمكن تكوينها من رموز A بأي طول، بما في ذلك السلسلة الفارغة (ε) التي تمثل السلسلة ذات الطول صفر."
    },
    {
        "question": "ما الفرق بين A* و A+؟",
        "options": [
            "A* تحتوي على السلسلة الفارغة، بينما A+ لا تحتوي عليها",
            "A+ تحتوي على السلسلة الفارغة، بينما A* لا تحتوي عليها",
            "A* تتضمن تكراراً واحداً على الأقل، بينما A+ تتضمن صفراً أو أكثر",
            "لا يوجد فرق، هما ترميزان مختلفان لنفس المفهوم"
        ],
        "correctAnswerIndex": 0,
        "explanation": "الفرق الجوهري هو أن A+ (الإغلاق الموجب) تمثل تكراراً واحداً أو أكثر للرموز من A، بينما A* (إغلاق كلين) تمثل تكراراً صفراً أو أكثر. بالتالي، A* تحتوي على ε بينما A+ لا تحتوي عليها. يمكن تعريف A+ بدلالة A* كالتالي: A+ = A A*."
    },
    {
        "question": "ما هي الخاصية التي تتمتع بها عملية الوصل (Concatenation) على السلاسل؟",
        "options": [
            "تبديلية (Commutative)",
            "تجميعية (Associative)",
            "توزيعية (Distributive)",
            "انعكاسية (Reflexive)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "عملية الوصل هي عملية تجميعية، بمعنى أن (ab)c = a(bc). لكنها ليست تبديلية، ففي الغالب ab ≠ ba."
    },
    {
        "question": "ما هو العنصر الحيادي لعملية الوصل على السلاسل؟",
        "options": [
            "المجموعة الخالية ∅",
            "السلسلة الفارغة ε",
            "أي رمز من الأبجدية",
            "لا يوجد عنصر حيادي"
        ],
        "correctAnswerIndex": 1,
        "explanation": "السلسلة الفارغة ε هي العنصر الحيادي لعملية الوصل، لأن وصل أي سلسلة s مع ε من اليمين أو اليسار يعطي نفس السلسلة s. أي أن s.ε = ε.s = s."
    },
    {
        "question": "في الأتومات المنتهي الحتمي (DFA)، ما هو مجال ومستقر تابع الانتقال δ؟",
        "options": [
            "δ: Q × Σ → 2^Q",
            "δ: Q × Σ → Q",
            "δ: Q → Σ",
            "δ: Q × Σ* → Q"
        ],
        "correctAnswerIndex": 1,
        "explanation": "في الأتومات الحتمي (DFA)، يأخذ تابع الانتقال δ حالة حالية (من Q) ورمز دخل (من Σ) وينتج حالة تالية واحدة بالضبط (من Q). الصيغة δ: Q × Σ → 2^Q تصف الأتومات اللاحتمي (NFA)."
    },
    {
        "question": "ماذا يعني أن الأتومات المنتهي 'حتمي' (Deterministic)؟",
        "options": [
            "لكل حالة، يوجد انتقال واحد على الأقل لأحد رموز الأبجدية",
            "لا يمكن وجود حلقات (loops) في مخطط الحالات",
            "لكل حالة وكل رمز من رموز الأبجدية، يوجد انتقال واحد وواحد فقط",
            "يجب أن تكون جميع الحالات نهائية"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الخاصية الحتمية تعني أنه لا يوجد أي غموض في الانتقال. لأي حالة معطاة وأي رمز دخل، المسار محدد بشكل فريد إلى حالة تالية واحدة."
    },
    {
        "question": "متى يقبل الأتومات المنتهي الحتمي (DFA) السلسلة w؟",
        "options": [
            "إذا كانت السلسلة w لا تسبب توقف الأتومات في حالة غير نهائية",
            "إذا كان طول السلسلة w يساوي عدد حالات الأتومات",
            "إذا كان الأتومات بعد قراءة w بأكملها في حالة تنتمي لمجموعة الحالات النهائية F",
            "إذا كان رمز البداية للسلسلة w له انتقال من الحالة الابتدائية"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الشرط الرسمي لقبول سلسلة w هو أن يكون الأتومات في حالة نهائية بعد معالجة السلسلة بأكملها، أي أن δ̂(q₀, w) ∈ F."
    },
    {
        "question": "ما هو الفرق الرئيسي في تابع الانتقال δ بين الأتومات الحتمي (DFA) واللاحتمي (NFA)؟",
        "options": [
            "تابع الانتقال في NFA يمكن أن يكون غير معرّف لبعض المدخلات",
            "مستقر تابع الانتقال في NFA هو مجموعة جزئية من الحالات (2^Q)",
            "الـ NFA يمتلك عدد حالات أكبر دائماً من الـ DFA المكافئ له",
            "الـ DFA لا يمكن أن يحتوي على انتقالات ε"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الفرق الجوهري يكمن في طبيعة الانتقال. في الـ DFA، الانتقال يكون إلى حالة واحدة (δ: Q × Σ → Q)، بينما في الـ NFA، الانتقال يكون إلى مجموعة من الحالات (δ: Q × Σ → 2^Q)."
    },
    {
        "question": "في خوارزمية بناء أتومات حتمي مكافئ لأتومات لاحتمي (Subset Construction)، ماذا تمثل كل حالة في الأتومات الحتمي الجديد؟",
        "options": [
            "حالة واحدة من الأتومات اللاحتمي الأصلي",
            "مسار كامل في الأتومات اللاحتمي",
            "مجموعة من حالات الأتومات اللاحتمي الأصلي",
            "رمز من أبجدية الدخل"
        ],
        "correctAnswerIndex": 2,
        "explanation": "كل حالة في الـ DFA الجديد تمثل مجموعة جزئية (subset) من حالات الـ NFA الأصلي. هذه هي الفكرة الأساسية في الخوارزمية لتغطية جميع المسارات الممكنة في الـ NFA."
    },
    {
        "question": "متى يقبل الأتومات المنتهي اللاحتمي (NFA) السلسلة w؟",
        "options": [
            "إذا انتهت جميع مسارات الحساب الممكنة في حالات نهائية",
            "إذا انتهى مسار واحد على الأقل من مسارات الحساب الممكنة في حالة نهائية",
            "إذا كان عدد المسارات الممكنة يساوي عدد الحالات النهائية",
            "إذا لم يستخدم الأتومات أي انتقال فارغ (ε) أثناء الحساب"
        ],
        "correctAnswerIndex": 1,
        "explanation": "القبول في الـ NFA يتطلب وجود مسار واحد على الأقل يؤدي إلى حالة نهائية. لا يشترط أن تؤدي جميع المسارات إلى حالات نهائية. الشرط الرسمي هو δ̂(q₀, w) ∩ F ≠ ∅."
    },
    {
        "question": "ماذا يعني وجود انتقال-ε في أتومات منتهي لاحتمي (NFA-ε)؟",
        "options": [
            "أن الأتومات ينتقل إلى حالة جديدة عند قراءة رمز غير معروف",
            "أن الأتومات يمكنه الانتقال إلى حالة أخرى دون استهلاك أي رمز من شريط الدخل",
            "أن الأتومات يتجاهل جميع رموز الدخل وينتقل مباشرة للحالة النهائية",
            "أن الأبجدية تحتوي على الرمز الفارغ"
        ],
        "correctAnswerIndex": 1,
        "explanation": "انتقالات-ε (أو الانتقالات الفارغة) تسمح للأتومات بتغيير حالته بشكل عفوي دون قراءة رمز من الدخل، مما يضيف درجة أخرى من اللاحتمية."
    },
    {
        "question": "ما هي العلاقة بين القوة التعبيرية لكل من DFA و NFA و NFA-ε؟",
        "options": [
            "NFA-ε أقوى من NFA، و NFA أقوى من DFA",
            "DFA أقوى من NFA و NFA-ε",
            "جميعها متكافئة في القوة التعبيرية وتقبل نفس صف اللغات (اللغات المنتظمة)",
            "NFA و NFA-ε متكافئة، لكن كلاهما أقوى من DFA"
        ],
        "correctAnswerIndex": 2,
        "explanation": "على الرغم من أن اللاحتمية وانتقالات-ε تبدو أكثر قوة، إلا أنه يمكن بناء DFA مكافئ لأي NFA أو NFA-ε. لذلك، جميع النماذج الثلاثة تصف نفس عائلة اللغات، وهي اللغات المنتظمة."
    },
    {
        "question": "ما هو ترتيب الأفضلية (Precedence) الصحيح للعمليات في التعابير المنتظمة (عند غياب الأقواس)؟",
        "options": [
            "الوصل (Concatenation)، ثم الاتحاد (+)، ثم إغلاق كلين (*)",
            "الاتحاد (+)، ثم الوصل، ثم إغلاق كلين (*)",
            "إغلاق كلين (*)، ثم الوصل، ثم الاتحاد (+)",
            "لا يوجد أفضلية، ويتم التقييم من اليسار إلى اليمين دائمًا"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الأفضلية العليا هي لإغلاق كلين (*)، تليها عملية الوصل (التسلسل)، وأدنى أفضلية لعملية الاتحاد (+). هذا مشابه لترتيب الأس، ثم الضرب، ثم الجمع في الحساب."
    },
    {
        "question": "أي لغة يصفها التعبير المنتظم (0+1)*00 على الأبجدية {0,1}؟",
        "options": [
            "جميع السلاسل التي تبدأ بـ 00",
            "جميع السلاسل التي تحتوي على 00",
            "جميع السلاسل التي تنتهي بـ 00",
            "جميع السلاسل التي تتكون من 0 و 1 وتليها 00"
        ],
        "correctAnswerIndex": 2,
        "explanation": "التعبير (0+1)* يمثل أي سلسلة من الأصفار والواحدات (بما في ذلك السلسلة الفارغة). عندما يتبعها 00، فإن اللغة الناتجة هي مجموعة كل السلاسل التي تنتهي بالمقطع 00."
    },
    {
        "question": "ما هو الاستخدام الرئيسي لتوطئة الضخ (Pumping Lemma) للغات المنتظمة؟",
        "options": [
            "لإثبات أن لغة ما هي لغة منتظمة",
            "لتحويل أتومات لاحتمي إلى حتمي",
            "لإثبات أن لغة ما ليست منتظمة",
            "لإيجاد أصغر تعبير منتظم للغة معينة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "توطئة الضخ هي أداة تستخدم لإظهار أن لغة معينة لا يمكن أن تكون منتظمة. يتم ذلك عن طريق إظهار أن اللغة لا تملك خاصية 'الضخ' التي يجب أن تتمتع بها جميع اللغات المنتظمة."
    },
    {
        "question": "في شروط توطئة الضخ للسلسلة z = uvw، أي من الشروط التالية يجب أن يتحقق؟",
        "options": [
            "|v| = 0",
            "|uv| > n حيث n هو ثابت الضخ",
            "uv^i w ∉ L لجميع i ≥ 0",
            "|v| ≥ 1"
        ],
        "correctAnswerIndex": 3,
        "explanation": "الشروط الثلاثة الأساسية لتوطئة الضخ هي: 1) |v| ≥ 1 (الجزء الذي يتم ضخه ليس فارغاً). 2) |uv| ≤ n. 3) لكل i ≥ 0، السلسلة uv^i w تنتمي إلى اللغة L. الخيارات الأخرى تخالف هذه الشروط."
    },
    {
        "question": "لماذا تعتبر اللغة {L = {a^n b^n | n ≥ 0 مثالاً كلاسيكياً على لغة غير منتظمة؟",
        "options": [
            "لأنها تحتوي على عدد لا نهائي من السلاسل",
            "لأنها تستخدم رمزين مختلفين من الأبجدية",
            "لأنها تتطلب 'عد' عدد a ومطابقته مع عدد b، والأتومات المنتهي لا يمتلك ذاكرة للعد غير المحدود",
            "لأنه لا يمكن كتابة تعبير منتظم لها باستخدام عملية الاتحاد فقط"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الأوتومات المنتهي له عدد محدود من الحالات، وبالتالي ذاكرة محدودة. لا يمكنه تذكر العدد الدقيق للحرف 'a' (إذا كان n كبيراً جداً) لمطابقته بعدد مساوٍ من الحرف 'b'. هذا يتطلب ذاكرة غير محدودة، وهو ما لا يوفره الأتومات المنتهي."
    },
    {
        "question": "أي من العمليات التالية لا تحافظ على انتظام اللغات (أي أن تطبيقها على لغات منتظمة قد ينتج لغة غير منتظمة)؟",
        "options": [
            "الاتحاد (Union)",
            "التقاطع (Intersection)",
            "الإتمام (Complement)",
            "جميع الخيارات المذكورة تحافظ على انتظام اللغات"
        ],
        "correctAnswerIndex": 3,
        "explanation": "اللغات المنتظمة مغلقة تحت عمليات الاتحاد، التقاطع، الإتمام، الوصل، وإغلاق كلين. هذا يعني أن تطبيق أي من هذه العمليات على لغات منتظمة سينتج دائمًا لغة منتظمة."
    },
    {
        "question": "مسألة تحديد ما إذا كانت لغة منتظمة معطاة فارغة أم لا هي مسألة:",
        "options": [
            "غير قابلة للقرار (Undecidable)",
            "قابلة للقرار (Decidable)",
            "NP-complete",
            "تعتمد على حجم الأبجدية"
        ],
        "correctAnswerIndex": 1,
        "explanation": "يمكن حل مسألة الفراغ (Emptiness Problem) للغات المنتظمة. إذا كان لدينا DFA يمثل اللغة، يمكننا ببساطة التحقق مما إذا كان هناك مسار من الحالة الابتدائية إلى أي حالة نهائية. هذه خوارزمية فعالة وقابلة للقرار."
    },
    {
        "question": "لتقليل عدد حالات أتومات منتهي حتمي (Minimization)، يتم دمج حالتين p و q إذا كانتا:",
        "options": [
            "متجاورتين في مخطط الحالات",
            "واحدة منهما ابتدائية والأخرى نهائية",
            "غير قابلتين للتمييز (Indistinguishable)",
            "لهما نفس عدد الانتقالات الخارجة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الحالتان p و q تكونان غير قابلتين للتمييز (أو متكافئتين) إذا كان لكل سلسلة w، إما أن تقود كل من p و q السلسلة w إلى حالات نهائية، أو كلتاهما إلى حالات غير نهائية. يتم دمج هذه الحالات لإنشاء الأتومات الأصغري."
    },
    {
        "question": "ما هو المكون الأساسي الذي يميز النماذج القواعدية خارج السياق (CFG) عن التعابير المنتظمة؟",
        "options": [
            "استخدام الرموز النهائية (Terminals)",
            "القدرة على توليد السلسلة الفارغة",
            "استخدام الرموز غير النهائية (Non-terminals) والعلاقات العودية (Recursive)",
            "وجود رمز بداية محدد"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الـ CFGs تستخدم متغيرات (رموز غير نهائية) وقواعد إنتاج يمكن أن تكون عودية (recursive)، مثل A → aAb. هذه العودية تسمح بتوليد بنى متداخلة ومتطابقة مثل a^n b^n، وهو ما لا تستطيعه التعابير المنتظمة."
    },
    {
        "question": "في النموذج القواعدي خارج السياق G = (V, T, P, S)، ماذا يمثل V؟",
        "options": [
            "مجموعة الرموز النهائية (الأبجدية)",
            "مجموعة الرموز غير النهائية (المتغيرات)",
            "مجموعة قواعد الإنتاج",
            "لغة النموذج القواعدي بأكملها"
        ],
        "correctAnswerIndex": 1,
        "explanation": "في التعريف الرسمي للـ CFG، يمثل V مجموعة منتهية من الرموز غير النهائية أو المتغيرات. T تمثل الرموز النهائية، P قواعد الإنتاج، و S رمز البداية."
    },
    {
        "question": "متى يعتبر النموذج القواعدي (Grammar) غامضاً (Ambiguous)؟",
        "options": [
            "إذا كانت اللغة التي يولدها لا نهائية",
            "إذا كان يحتوي على قواعد ε",
            "إذا كانت هناك سلسلة واحدة على الأقل لها شجرتا اشتقاق (Parse Trees) مختلفتان",
            "إذا كان عدد قواعده أكبر من عدد رموزه غير النهائية"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الغموض هو خاصية للنموذج القواعدي وليس للغة بالضرورة. يحدث الغموض عندما يمكن اشتقاق سلسلة معينة بأكثر من طريقة واحدة، مما يؤدي إلى وجود أكثر من شجرة اشتقاق، أو أكثر من اشتقاق يساري، أو أكثر من اشتقاق يميني."
    },
    {
        "question": "ما هي الصيغة التي يجب أن تكون عليها جميع قواعد الإنتاج في صيغة تشومسكي المعيارية (Chomsky Normal Form)؟",
        "options": [
            "A → aB أو A → ε",
            "A → Ba أو A → a",
            "A → BC أو A → a",
            "A → aBC أو A → b"
        ],
        "correctAnswerIndex": 2,
        "explanation": "صيغة تشومسكي المعيارية (CNF) تفرض قيودًا صارمة على شكل القواعد. يجب أن تكون كل قاعدة إما من الشكل A → BC (رمز غير نهائي ينتج رمزين غير نهائيين) أو A → a (رمز غير نهائي ينتج رمزاً نهائياً واحداً)."
    },
    {
        "question": "لماذا يعد تحويل النموذج القواعدي إلى صيغة تشومسكي المعيارية (CNF) مفيداً؟",
        "options": [
            "لأنه يزيل الغموض من النموذج القواعدي دائماً",
            "لأنه يقلل من عدد القواعد بشكل كبير",
            "لأنه يسهل العديد من الخوارزميات، مثل خوارزمية CYK للتحليل (Parsing)",
            "لأنه يضمن أن اللغة المولدة منتظمة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "صيغة CNF لها بنية منتظمة جداً. هذه البنية تجعل شجرة الاشتقاق لأي سلسلة شجرة ثنائية، وهو أمر مفيد للغاية في تطوير خوارزميات التحليل الإعرابي (parsing) مثل خوارزمية Cocke-Younger-Kasami (CYK)."
    },
    {
        "question": "ما هو الهدف من عملية إزالة 'القواعد الأحادية' (Unit Productions) مثل A → B من النموذج القواعدي؟",
        "options": [
            "للتخلص من الرموز غير المفيدة",
            "لجعل النموذج القواعدي يولد لغة منتهية",
            "لتبسيط النموذج ومنع سلاسل الاشتقاق غير الضرورية التي لا تولد رموزاً نهائية",
            "لتحويل النموذج إلى صيغة Greibach المعيارية"
        ],
        "correctAnswerIndex": 2,
        "explanation": "القواعد الأحادية (A → B) تطيل الاشتقاقات دون أن تضيف رموزاً نهائية إلى السلسلة. إزالتها تجعل الاشتقاقات أكثر مباشرة وتقلل من التعقيد، وهي خطوة أساسية في عملية تبسيط النماذج القواعدية."
    },
    {
        "question": "إذا كان لدينا الأتومات اللاحتمي المعرف بالجدول التالي (q0 هي الحالة الابتدائية والنهائية)، أي من السلاسل التالية مقبولة؟ δ(q0,0)={q0,q1}, δ(q0,1)={q0}, δ(q1,1)={q0}",
        "options": [
            "010",
            "101",
            "001",
            "110"
        ],
        "correctAnswerIndex": 1,
        "explanation": "السلسلة 101 مقبولة. المسار: q0 --(1)--> q0 --(0)--> q1 --(1)--> q0. بما أننا انتهينا في الحالة النهائية q0، فالسلسلة مقبولة."
    },
    {
        "question": "التعبير المنتظم (a|b)*b(a|b)* يصف لغة:",
        "options": [
            "كل السلاسل التي تبدأ بـ b",
            "كل السلاسل التي تحتوي على b واحدة على الأقل",
            "كل السلاسل التي تنتهي بـ b",
            "كل السلاسل التي تحتوي على b مرة واحدة فقط"
        ],
        "correctAnswerIndex": 1,
        "explanation": "التعبير (a|b)* يعني أي سلسلة من a و b. وجود b في المنتصف يضمن أن الحرف b يجب أن يظهر مرة واحدة على الأقل في أي سلسلة تولدها اللغة."
    },
    {
        "question": "ماذا يمثل الـ ε-closure(q) لحالة q في NFA-ε؟",
        "options": [
            "الحالة q نفسها فقط",
            "جميع الحالات التي يمكن الوصول إليها من q بقراءة رمز واحد",
            "جميع الحالات التي يمكن الوصول إليها من q عبر سلسلة من انتقالات-ε (بما في ذلك q نفسها)",
            "مجموعة الحالات النهائية التي يمكن الوصول إليها من q"
        ],
        "correctAnswerIndex": 2,
        "explanation": "إغلاق إبسيلون لحالة q هو مجموعة كل الحالات التي يمكن الوصول إليها من q باتباع صفر أو أكثر من انتقالات-ε. وهذا يشمل دائماً الحالة q نفسها (صفر انتقالات)."
    },
    {
        "question": "أي من اللغات التالية ليست لغة خارجة عن السياق (not context-free)؟",
        "options": [
            "{a^n b^n | n ≥ 0}",
            "{ww | w ∈ {a,b}*}",
            "{a^n b^2n | n ≥ 0}",
            "{a^n b^n c^n | n ≥ 0}"
        ],
        "correctAnswerIndex": 3,
        "explanation": "اللغة {a^n b^n c^n} هي المثال الكلاسيكي للغة ليست خارجة عن السياق. تتطلب هذه اللغة مطابقة ثلاثة أعداد، وهو ما يتجاوز قدرة الذاكرة المكدسية (stack) التي تميز أوتومات الدفع السفلي (PDA) الذي يقبل اللغات خارجة السياق."
    },
    {
        "question": "في الاشتقاق اليساري (Leftmost derivation)، أي رمز يتم استبداله في كل خطوة؟",
        "options": [
            "الرمز غير النهائي الأقصى يميناً",
            "الرمز النهائي الأقصى يساراً",
            "الرمز غير النهائي الأقصى يساراً",
            "أي رمز غير نهائي يتم اختياره عشوائياً"
        ],
        "correctAnswerIndex": 2,
        "explanation": "التعريف الدقيق للاشتقاق اليساري هو أنه في كل خطوة من الاشتقاق، يتم تطبيق قاعدة إنتاج على المتغير (الرمز غير النهائي) الموجود في أقصى يسار السلسلة الحالية."
    },
    {
        "question": "ماذا ينتج عن عملية 'اختصار الرموز عديمة الفائدة' في نموذج قواعدي؟",
        "options": [
            "نموذج قواعدي جديد يولد لغة أصغر",
            "نموذج قواعدي جديد يولد لغة أكبر",
            "نموذج قواعدي جديد يولد نفس اللغة بالضبط ولكنه أبسط",
            "نموذج قواعدي خالٍ من الغموض"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الرموز عديمة الفائدة هي تلك التي لا يمكن الوصول إليها من رمز البداية، أو التي لا يمكنها اشتقاق سلسلة من الرموز النهائية. إزالتها لا تغير اللغة المولدة، ولكنها تبسط النموذج القواعدي."
    },
    {
        "question": "لغة جميع السلاسل الثنائية التي تمثل أعداداً زوجية يمكن وصفها بالتعبير المنتظم:",
        "options": [
            "(0|1)*0",
            "0(0|1)*",
            "(0|1)0*",
            "0*(0|1)"
        ],
        "correctAnswerIndex": 0,
        "explanation": "العدد الثنائي يكون زوجياً إذا وفقط إذا كان الرقم الأقل أهمية (الخانة اليمنى) هو 0. التعبير (0|1)* يمثل أي سلسلة ثنائية، وعندما يتبعها 0، فإنه يضمن أن السلسلة تنتهي بصفر."
    },
    {
        "question": "إذا كانت L1 و L2 لغتين منتظمتين، فأي من اللغات التالية ليست بالضرورة منتظمة؟",
        "options": [
            "L1 ∪ L2",
            "L1 ∩ L2",
            "L1.L2 (Concatenation)",
            "جميع الخيارات المذكورة هي لغات منتظمة"
        ],
        "correctAnswerIndex": 3,
        "explanation": "اللغات المنتظمة مغلقة تحت عمليات الاتحاد، التقاطع، والوصل. هذا يعني أن نتيجة هذه العمليات على لغات منتظمة هي دائمًا لغة منتظمة."
    },
    {
        "question": "الأتومات الأصغري (Minimal DFA) للغة منتظمة معينة يكون:",
        "options": [
            "فريداً (Unique) باستثناء أسماء الحالات",
            "أحد الأتوماتات الممكنة المتعددة",
            "دائماً لاحتمياً",
            "يحتوي على حالة نهائية واحدة فقط"
        ],
        "correctAnswerIndex": 0,
        "explanation": "نظرية Myhill-Nerode تضمن أنه لكل لغة منتظمة، يوجد أتومات منتهي حتمي واحد فقط (يصل إلى التماثل أو إعادة تسمية الحالات) بأقل عدد ممكن من الحالات."
    },
    {
        "question": "قاعدة الإنتاج A → ε تسمى:",
        "options": [
            "قاعدة أحادية (Unit Production)",
            "قاعدة إبسيلون (ε-production)",
            "قاعدة نهائية (Terminal Production)",
            "قاعدة عودية (Recursive Production)"
        ],
        "correctAnswerIndex": 1,
        "explanation": "أي قاعدة يكون طرفها الأيمن هو السلسلة الفارغة (ε) تسمى قاعدة إبسيلون. هذه القواعد تسمح للمتغيرات بالاختفاء من السلسلة المشتقة."
    },
    {
        "question": "ما هو ناتج تقاطع لغة منتظمة مع لغة خارجة عن السياق؟",
        "options": [
            "دائماً لغة منتظمة",
            "دائماً لغة خارجة عن السياق",
            "قد تكون لغة ليست خارجة عن السياق",
            "دائماً لغة فارغة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "اللغات خارجة السياق مغلقة تحت التقاطع مع اللغات المنتظمة. هذا يعني أن نتيجة العملية ستكون دائماً لغة خارجة عن السياق (وقد تكون منتظمة في حالات خاصة)."
    },
    {
        "question": "في النموذج القواعدي G، إذا كان S ⇒* α، حيث S هو رمز البداية و α سلسلة من الرموز النهائية، فإن α تسمى:",
        "options": [
            "شجرة اشتقاق",
            "رمز غير نهائي",
            "سلسلة جملية (Sentential Form)",
            "سلسلة مقبولة في لغة G"
        ],
        "correctAnswerIndex": 3,
        "explanation": "أي سلسلة يمكن اشتقاقها من رمز البداية تسمى 'سلسلة جملية'. إذا كانت هذه السلسلة تتكون فقط من رموز نهائية، فهي سلسلة تنتمي إلى اللغة التي يولدها النموذج القواعدي L(G)."
    },
    {
        "question": "أي من الخيارات التالية لا يمكن تمثيله باستخدام أتومات منتهي حتمي؟",
        "options": [
            "التحقق من أن عدد الواحدات في سلسلة ثنائية هو عدد زوجي",
            "التحقق من أن سلسلة تنتهي بالنمط 'aba'",
            "التحقق من أن سلسلة هي 'palindrome' (تقرأ من اليمين واليسار بنفس الشكل)",
            "التحقق من أن سلسلة تحتوي على عدد فردي من الأصفار"
        ],
        "correctAnswerIndex": 2,
        "explanation": "لغة الـ palindromes (مثل 'aba', 'racecar') ليست منتظمة. التحقق منها يتطلب مقارنة بداية السلسلة بنهايتها، وهو ما يتطلب ذاكرة غير محدودة لتخزين النصف الأول من السلسلة، وهو ما لا يملكه الأتومات المنتهي."
    },
    {
        "question": "عند تحويل NFA إلى DFA مكافئ، يمكن أن يصل عدد حالات الـ DFA الجديد إلى:",
        "options": [
            "n",
            "n^2",
            "2^n",
            "n!"
        ],
        "correctAnswerIndex": 2,
        "explanation": "في أسوأ الحالات، يمكن أن يكون عدد حالات الـ DFA المكافئ هو 2^n، حيث n هو عدد حالات الـ NFA الأصلي. هذا لأن كل حالة في الـ DFA تمثل مجموعة جزئية من حالات الـ NFA، وعدد المجموعات الجزئية الممكنة هو 2^n."
    },
    {
        "question": "التعبير المنتظم ε + 0(0|1)* يصف:",
        "options": [
            "لغة السلاسل الثنائية التي تبدأ بصفر",
            "لغة السلاسل الثنائية التي تبدأ بصفر، بالإضافة إلى السلسلة الفارغة",
            "السلسلة الفارغة فقط",
            "جميع السلاسل الثنائية"
        ],
        "correctAnswerIndex": 1,
        "explanation": "التعبير 0(0|1)* يصف جميع السلاسل التي تبدأ بصفر. الرمز '+' يعني الاتحاد، و 'ε' يمثل السلسلة الفارغة. لذلك، اللغة هي اتحاد مجموعة السلاسل التي تبدأ بصفر مع مجموعة تحتوي على السلسلة الفارغة فقط."
    },
    {
        "question": "ما هو دور شجرة الاشتقاق (Parse Tree)؟",
        "options": [
            "تحديد ما إذا كانت اللغة منتظمة أم لا",
            "تمثيل بنية السلسلة وكيفية اشتقاقها من النموذج القواعدي بشكل رسومي",
            "إيجاد أقصر سلسلة في اللغة",
            "حساب عدد الحالات في الأتومات المكافئ"
        ],
        "correctAnswerIndex": 1,
        "explanation": "شجرة الاشتقاق توضح بشكل هرمي كيف تم تطبيق قواعد الإنتاج لتوليد سلسلة معينة من رمز البداية. هي تمثيل مرئي لعملية الاشتقاق وتكشف عن البنية النحوية للسلسلة."
    },
    {
        "question": "قاعدة مثل A → aA | ε هي مثال على:",
        "options": [
            "قاعدة لا معنى لها",
            "قاعدة غامضة",
            "قاعدة عودية (Recursive)",
            "قاعدة غير مسموح بها في CFG"
        ],
        "correctAnswerIndex": 2,
        "explanation": "هذه القاعدة عودية لأن الرمز غير النهائي A يظهر في الطرف الأيمن من القاعدة التي هو رأسها. هذه العودية (مع الحالة الأساسية A → ε) تسمح بتوليد سلاسل من الشكل a*."
    },
    {
        "question": "إذا كان الأتومات المنتهي الحتمي في حالة غير نهائية وبعد قراءة كامل السلسلة، فإن السلسلة:",
        "options": [
            "مقبولة",
            "مرفوضة",
            "تعتبر غامضة",
            "تحتاج إلى إعادة قراءة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الشرط الوحيد لقبول سلسلة في DFA هو أن تكون الحالة النهائية للأتومات بعد قراءة السلسلة بأكملها هي حالة نهائية. إذا كانت الحالة النهائية غير نهائية، فالسلسلة مرفوضة."
    },
    {
        "question": "ما هي اللغة التي يولدها النموذج القواعدي التالي: S → aSb | ε",
        "options": [
            "{a^n b^m | n, m ≥ 0}",
            "{(ab)^n | n ≥ 0}",
            "{a^n b^n | n ≥ 0}",
            "جميع السلاسل التي تبدأ بـ a وتنتهي بـ b"
        ],
        "correctAnswerIndex": 2,
        "explanation": "هذا هو النموذج القواعدي الكلاسيكي لتوليد اللغة {a^n b^n}. في كل مرة يتم تطبيق القاعدة S → aSb، يتم إضافة 'a' في البداية و 'b' في النهاية. القاعدة S → ε توقف الاشتقاق."
    },
    {
        "question": "ماذا يحدث عند تطبيق عملية الإتمام (Complement) على لغة منتظمة؟",
        "options": [
            "اللغة الناتجة ليست منتظمة",
            "اللغة الناتجة هي نفسها اللغة الأصلية",
            "اللغة الناتجة هي لغة منتظمة تحتوي على كل السلاسل التي لم تكن في اللغة الأصلية",
            "اللغة الناتجة هي المجموعة الخالية"
        ],
        "correctAnswerIndex": 2,
        "explanation": "لإيجاد مكمل لغة منتظمة ممثلة بـ DFA، نقوم ببساطة بتبديل الحالات النهائية وغير النهائية. الأتومات الجديد يقبل بالضبط السلاسل التي كان يرفضها الأتومات الأصلي، والناتج هو لغة منتظمة."
    },
    {
        "question": "في الأتومات المنتهي اللاحتمي، إذا كان δ(q, a) = ∅، ماذا يعني ذلك؟",
        "options": [
            "أن الأتومات يقبل السلسلة a",
            "أن هناك خطأ في تعريف الأتومات",
            "أن الأتومات يتوقف عند هذه النقطة (يموت المسار)",
            "أن الأتومات ينتقل إلى حالة ابتدائية جديدة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "عندما يكون ناتج تابع الانتقال هو المجموعة الخالية ∅، فهذا يعني أنه لا يوجد انتقال ممكن من الحالة q بالرمز a. هذا المسار من الحساب يتوقف ولا يمكنه المتابعة، ويعتبر مساراً ميتاً."
    },
    {
        "question": "أي تعبير منتظم يمثل لغة السلاسل الثنائية التي لا تحتوي على '11' متتالية؟",
        "options": [
            "(0|10)* (1|ε)",
            "(0*1)*",
            "1*0*1*",
            "(1|01)*"
        ],
        "correctAnswerIndex": 0,
        "explanation": "التعبير (0|10)* يولد سلاسل لا تحتوي على '11'. كل '1' يجب أن يتبعه '0' فوراً. الجزء (1|ε) في النهاية يسمح للسلسلة بالانتهاء بـ '1' إذا لزم الأمر."
    },
    {
        "question": "ماذا تعني عبارة 'اللغات المنتظمة مغلقة تحت عملية التقاطع'؟",
        "options": [
            "تقاطع أي لغتين منتظمتين هو دائماً المجموعة الخالية",
            "لا يمكن إيجاد تقاطع لغتين منتظمتين",
            "تقاطع أي لغتين منتظمتين هو دائماً لغة منتظمة أيضاً",
            "تقاطع لغة منتظمة مع أي لغة أخرى هو لغة منتظمة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "خاصية الانغلاق تعني أن تطبيق العملية على عناصر من مجموعة معينة (هنا اللغات المنتظمة) ينتج عنصراً ينتمي إلى نفس المجموعة. يمكن بناء أتومات لتقاطع لغتين منتظمتين، وبالتالي فالناتج منتظم."
    },
    {
        "question": "إذا كان لدينا قاعدة الإنتاج A → a | B في نموذج قواعدي، وقاعدة أخرى B → b، فما هي العملية التي تسمح باستبدالها بـ A → a | b؟",
        "options": [
            "إزالة قواعد إبسيلون",
            "إزالة الرموز عديمة الفائدة",
            "إزالة القواعد الأحادية",
            "التحويل إلى صيغة تشومسكي"
        ],
        "correctAnswerIndex": 2,
        "explanation": "القاعدة A → B هي قاعدة أحادية. عملية إزالة القواعد الأحادية تتضمن استبدال القاعدة A → B بجميع قواعد B التي لا تؤدي إلى قواعد أحادية أخرى. في هذه الحالة، يتم استبدالها بـ A → b."
    },
    {
        "question": "ما هو الحد الأدنى لعدد الحالات في DFA يقبل لغة السلاسل الثنائية التي تحتوي على عدد زوجي من الأصفار؟",
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correctAnswerIndex": 1,
        "explanation": "نحتاج إلى حالتين: حالة لتمثيل 'عدد زوجي من الأصفار حتى الآن' (وهي الحالة الابتدائية والنهائية)، وحالة لتمثيل 'عدد فردي من الأصفار حتى الآن'. قراءة 0 تبدل بين الحالتين، وقراءة 1 تبقي الأتومات في حالته الحالية."
    },
    {
        "question": "أي من التعابير المنتظمة التالية مكافئ للتعبير a*a؟",
        "options": [
            "a",
            "a+",
            "aa*",
            "كلا من a+ و aa*"
        ],
        "correctAnswerIndex": 3,
        "explanation": "a*a يعني 'صفر أو أكثر من a' تليها 'a'، وهو ما يعني 'واحد أو أكثر من a'، والذي يمثله a+. كذلك، aa* يعني 'a' تليها 'صفر أو أكثر من a'، وهو ما يعني أيضاً 'واحد أو أكثر من a'. لذلك كلا التعبيرين مكافئان."
    },
    {
        "question": "في سياق تبسيط النماذج القواعدية، ما هو 'الرمز الذي لا يمكن الوصول إليه' (Unreachable Symbol)؟",
        "options": [
            "رمز لا يمكنه اشتقاق سلسلة من الرموز النهائية",
            "رمز لا يظهر في أي قاعدة إنتاج",
            "رمز لا يمكن اشتقاقه من رمز البداية S",
            "رمز نهائي يظهر في الطرف الأيسر من قاعدة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الرمز الذي لا يمكن الوصول إليه هو أي رمز (نهائي أو غير نهائي) لا يمكن أن يظهر في أي سلسلة جملية مشتقة من رمز البداية S. هذه الرموز وقواعدها المرتبطة بها يمكن إزالتها دون التأثير على اللغة المولدة."
    },
    {
        "question": "أي نوع من الأتوماتات يقبل اللغات خارجة السياق (Context-Free Languages)؟",
        "options": [
            "أتومات منتهي حتمي (DFA)",
            "أتومات منتهي لاحتمي (NFA)",
            "أتومات الدفع السفلي (Pushdown Automaton)",
            "آلة تورنغ (Turing Machine)"
        ],
        "correctAnswerIndex": 2,
        "explanation": "هناك علاقة مباشرة بين أنواع النماذج القواعدية وأنواع الأتوماتات. اللغات المنتظمة تقبلها الأتوماتات المنتهية (DFA/NFA)، بينما اللغات خارجة السياق تتطلب قوة إضافية متمثلة في مكدس (stack)، وهو ما يوفره أتومات الدفع السفلي (PDA)."
    },
    {
        "question": "إذا كانت اللغة L = L(M) لأتومات منتهي M، فإن L* (إغلاق كلين للغة) هي أيضاً لغة منتظمة. كيف يمكن بناء أتومات لـ L* من M؟",
        "options": [
            "بجعل جميع حالات M نهائية",
            "بإضافة حلقة (loop) على كل حالة نهائية لجميع رموز الأبجدية",
            "بجعل الحالة الابتدائية نهائية وإضافة انتقالات-ε من الحالات النهائية القديمة إلى الحالة الابتدائية",
            "لا يمكن بناؤه، يجب البدء من تعبير منتظم جديد"
        ],
        "correctAnswerIndex": 2,
        "explanation": "الطريقة القياسية لبناء أتومات لـ L* هي: 1) إنشاء حالة ابتدائية جديدة وجعلها نهائية (لقبول السلسلة الفارغة). 2) إضافة انتقال-ε من الحالة الابتدائية الجديدة إلى الحالة الابتدائية القديمة. 3) إضافة انتقالات-ε من كل حالة نهائية قديمة إلى الحالة الابتدائية القديمة (للسماح بالوصل المتكرر)."
    },
    {
        "question": "ماذا تمثل شجرة الاشتقاق (Parse Tree) التي تكون فيها كل عقدة داخلية لها ابنان بالضبط؟",
        "options": [
            "اشتقاق من نموذج قواعدي غامض",
            "اشتقاق من نموذج قواعدي بصيغة Greibach",
            "اشتقاق من نموذج قواعدي بصيغة تشومسكي (CNF)",
            "اشتقاق لسلسلة تحتوي على رموز زوجية فقط"
        ],
        "correctAnswerIndex": 2,
        "explanation": "بما أن كل قاعدة في CNF هي إما A → BC أو A → a، فإن أي عقدة داخلية في شجرة الاشتقاق (التي تمثل تطبيق قاعدة) ستكون لها إما ابنان (للقاعدة A → BC) أو ابن واحد (ورقة) (للقاعدة A → a). هذا يؤدي إلى شجرة تكون فيها كل عقدة داخلية لها ابنان."
    },
    {
        "question": "لغة جميع السلاسل على {a, b} التي لا تنتهي بـ 'b' يمكن وصفها بالتعبير المنتظم:",
        "options": [
            "(a|b)*a",
            "(a|b)*a + ε",
            "a(a|b)*",
            "a*b*a"
        ],
        "correctAnswerIndex": 1,
        "explanation": "السلاسل التي لا تنتهي بـ 'b' هي إما السلسلة الفارغة (ε) أو السلاسل التي تنتهي بـ 'a'. الخيار (a|b)*a يصف السلاسل التي تنتهي بـ 'a'. بإضافة ε (عبر الاتحاد +)، نحصل على جميع السلاسل المطلوبة."
    },
    {
        "question": "ما هي نتيجة تطبيق خوارزمية تصغير الـ DFA على DFA هو بالأصل أصغري؟",
        "options": [
            "ينتج DFA بحالات أقل",
            "تفشل الخوارزمية",
            "ينتج DFA بنفس عدد الحالات (مكافئ للأصلي)",
            "ينتج NFA"
        ],
        "correctAnswerIndex": 2,
        "explanation": "خوارزمية التصغير تدمج الحالات المتكافئة. إذا كان الـ DFA أصغرياً بالفعل، فهذا يعني أنه لا توجد أي حالتين متكافئتين يمكن دمجهما. وبالتالي، ستنتهي الخوارزمية دون أي تغيير، وينتج نفس الـ DFA."
    },
    {
        "question": "النموذج القواعدي S → SS | a يولد:",
        "options": [
            "لغة السلاسل التي تحتوي على عدد زوجي من a",
            "لغة السلاسل التي تحتوي على a واحدة على الأقل",
            "لغة السلاسل التي تبدأ وتنتهي بـ a",
            "فقط السلسلة a"
        ],
        "correctAnswerIndex": 1,
        "explanation": "يمكن اشتقاق a (باستخدام S → a). ويمكن اشتقاق aa (عبر S → SS → aS → aa). ويمكن اشتقاق aaa (عبر S → SS → SSS → ...). القاعدة S → SS تسمح بتوليد أي عدد من a، والقاعدة S → a تضمن وجود واحدة على الأقل. اللغة هي a+."
    },
    {
        "question": "ما هي أول خطوة يتم تنفيذها عادة عند تبسيط نموذج قواعدي خارج السياق؟",
        "options": [
            "إزالة القواعد الأحادية (Unit productions)",
            "إزالة قواعد إبسيلون (ε-productions)",
            "إزالة الرموز عديمة الفائدة (Useless symbols)",
            "الترتيب المعتاد هو إزالة قواعد إبسيلون، ثم الأحادية، ثم الرموز عديمة الفائدة"
        ],
        "correctAnswerIndex": 3,
        "explanation": "الترتيب مهم لأن إحدى العمليات قد تولد نوعًا جديدًا من القواعد التي تحتاج إلى إزالة لاحقًا. الترتيب القياسي هو: 1. إزالة قواعد ε. 2. إزالة القواعد الأحادية. 3. إزالة الرموز عديمة الفائدة. هذا يضمن تبسيطًا كاملاً."
    },
    {
        "question": "ما هو التعبير المنتظم الذي يمثل الأعداد الصحيحة (integer literals) في لغات البرمجة (عدد اختياري من الأرقام يسبقه إشارة اختيارية + أو -)؟",
        "options": [
            "(+|-|ε) (0|1|...|9)+",
            "(+-) (0-9)*",
            "[+-]?[0-9]*",
            "(+|-) (0|...|9)*"
        ],
        "correctAnswerIndex": 0,
        "explanation": "التعبير (+|-|ε) يمثل إشارة اختيارية (+ أو - أو لا شيء). والتعبير (0|1|...|9)+ يمثل رقمًا واحدًا أو أكثر. هذا يطابق تعريف الأعداد الصحيحة مثل '123' و '-5' و '+99'."
    },
    {
        "question": "إذا كانت لغة ما منتظمة، فإن عكسها (reverse) يكون:",
        "options": [
            "دائماً منتظم",
            "أحياناً منتظم",
            "أبداً ليس منتظم",
            "لغة خارجة عن السياق"
        ],
        "correctAnswerIndex": 0,
        "explanation": "اللغات المنتظمة مغلقة تحت عملية العكس. يمكن بناء NFA يقبل عكس اللغة L عن طريق عكس جميع انتقالات الـ DFA الأصلي، وجعل الحالة الابتدائية القديمة هي الحالة النهائية الجديدة، والحالات النهائية القديمة هي الحالات الابتدائية."
    },
    {
        "question": "نموذج قواعدي يسمى 'خارج السياق' لأن:",
        "options": [
            "قواعده يمكن تطبيقها في أي سياق لغوي",
            "قواعده لا تعتمد على الرموز المجاورة للمتغير الذي يتم استبداله",
            "لا يمكن استخدامه لتحليل سياق الجملة",
            "يمكن استخدامه خارج سياق علوم الحاسب"
        ],
        "correctAnswerIndex": 1,
        "explanation": "يأتي الاسم 'خارج السياق' (Context-Free) من أن قاعدة الإنتاج A → α يمكن تطبيقها على المتغير A بغض النظر عن الرموز التي تأتي قبله أو بعده في السلسلة الجملية. هذا يختلف عن النماذج القواعدية الحساسة للسياق (Context-Sensitive)."
    },
    {
        "question": "ما هي اللغة التي يقبلها أتومات منتهي بحالة واحدة، وهي ابتدائية ونهائية في نفس الوقت، ولها حلقة على نفسها لجميع رموز الأبجدية Σ؟",
        "options": [
            "اللغة الفارغة ∅",
            "اللغة التي تحتوي على السلسلة الفارغة فقط {ε}",
            "جميع السلاسل الممكنة على الأبجدية Σ*",
            "جميع السلاسل ذات الطول 1"
        ],
        "correctAnswerIndex": 2,
        "explanation": "بما أن الحالة الابتدائية هي حالة نهائية، فإنه يقبل السلسلة الفارغة (ε). وبما أن هناك حلقة على هذه الحالة لجميع رموز الأبجدية، فإنه يمكنه قراءة أي رمز والبقاء في الحالة النهائية. وبالتالي، فإنه يقبل أي سلسلة من أي طول، أي Σ*."
    },
    {
        "question": "في النموذج القواعدي S → SS | a يولد:",
        "options": [
            "لغة السلاسل التي تحتوي على عدد زوجي من a",
            "لغة السلاسل التي تحتوي على a واحدة على الأقل",
            "لغة السلاسل التي تبدأ وتنتهي بـ a",
            "فقط السلسلة a"
        ],
        "correctAnswerIndex": 1,
        "explanation": "يمكن اشتقاق a (باستخدام S → a). ويمكن اشتقاق aa (عبر S → SS → aS → aa). ويمكن اشتقاق aaa (عبر S → SS → SSS → ...). القاعدة S → SS تسمح بتوليد أي عدد من a، والقاعدة S → a تضمن وجود واحدة على الأقل. اللغة هي a+."
    },
    {
        "question": "ما هو ناتج الوصل (Concatenation) بين اللغة L1 = {a, ab} و L2 = {b, ba}؟",
        "options": [
            "{ab, aba, abb, abba}",
            "{ab}",
            "{aba, abb}",
            "{ab, abba}"
        ],
        "correctAnswerIndex": 0,
        "explanation": "عملية الوصل L1.L2 تتضمن وصل كل سلسلة من L1 مع كل سلسلة من L2. النتائج هي: a.b = ab, a.ba = aba, ab.b = abb, ab.ba = abba."
    },
    {
        "question": "أي من القواعد التالية تنتهك صيغة تشومسكي المعيارية (CNF)؟",
        "options": [
            "A → BC",
            "B → a",
            "C → aB",
            "جميعها تتبع الصيغة"
        ],
        "correctAnswerIndex": 2,
        "explanation": "القاعدة C → aB تنتهك صيغة CNF لأن الطرف الأيمن يحتوي على مزيج من رمز نهائي (a) ورمز غير نهائي (B). قواعد CNF يجب أن تكون إما A → BC (رمزان غير نهائيين) أو A → a (رمز نهائي واحد)."
    },
    {
        "question": "إذا كان الأتومات المنتهي لا يحتوي على أي حالة نهائية، فما هي اللغة التي يقبلها؟",
        "options": [
            "اللغة الفارغة ∅",
            "اللغة التي تحتوي على ε فقط",
            "جميع السلاسل الممكنة Σ*",
            "هذا الأتومات غير صالح"
        ],
        "correctAnswerIndex": 0,
        "explanation": "لكي يقبل الأتومات أي سلسلة، يجب أن ينتهي مسار الحساب في حالة نهائية. إذا لم تكن هناك حالات نهائية على الإطلاق، فلا يمكن لأي سلسلة أن تُقبل، وبالتالي فإن اللغة التي يقبلها الأتومات هي اللغة الفارغة ∅."
    },
    {
        "question": "التعبير المنتظم (a*b*)* مكافئ لـ:",
        "options": [
            "a*b*",
            "(a|b)*",
            "ab*",
            "a*b"
        ],
        "correctAnswerIndex": 1,
        "explanation": "التعبير a*b* يولد سلاسل تتكون من أي عدد من a تليها أي عدد من b. عندما نطبق إغلاق كلين (*) على هذا التعبير، فإننا نسمح بتكرار هذه الأنماط بأي ترتيب. هذا يسمح بتوليد أي سلسلة من a و b، وهو ما يكافئ (a|b)*."
    },
    {
        "question": "في عملية تحويل تعبير منتظم إلى NFA-ε، ماذا يمثل البناء الخاص بعملية الاتحاد (r1+r2)؟",
        "options": [
            "وصل الأتوماتين r1 و r2 على التوالي",
            "إنشاء حلقة من نهاية أتومات r1 إلى بدايته",
            "إنشاء حالة بداية جديدة تنتقل بـ ε إلى بدايتي أتوماتي r1 و r2، وحالة نهاية جديدة تتلقى انتقالات بـ ε من نهايتي أتوماتي r1 و r2",
            "دمج حالة بداية r1 مع حالة نهاية r2"
        ],
        "correctAnswerIndex": 2,
        "explanation": "هذه هي الطريقة القياسية (خوارزمية طومسون) لبناء أتومات للاتحاد. يتم إنشاء مسارين متوازيين، واحد لـ r1 والآخر لـ r2، مما يسمح للأتومات باختيار أي من المسارين بشكل لاحتمي."
    },
    {
        "question": "ما هو الحد الأدنى لعدد الحالات في DFA يقبل لغة السلاسل الثنائية التي يكون طولها من مضاعفات 3؟",
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correctAnswerIndex": 2,
        "explanation": "نحتاج إلى ثلاث حالات لتمثيل باقي القسمة على 3: حالة للباقي 0 (الابتدائية والنهائية)، حالة للباقي 1، وحالة للباقي 2. كل رمز يتم قراءته ينقل الأتومات من حالة الباقي i إلى حالة الباقي (i+1) mod 3."
    },
    {
        "question": "النموذج القواعدي S → aA, A → bS | a يولد سلاسل من أي نوع؟",
        "options": [
            "سلاسل تحتوي على ab متكرر، مثل ab, abab, ...",
            "سلاسل تحتوي على عدد متساو من a و b",
            "سلاسل تبدأ بـ a وتنتهي بـ a",
            "سلاسل تحتوي على نمط a...a فقط"
        ],
        "correctAnswerIndex": 0,
        "explanation": "بدءًا من S، يجب أن نولد 'a' وننتقل إلى A (S → aA). من A، يمكننا إما إنهاء السلسلة بـ 'a' (A → a) لنحصل على 'aa'، أو نولد 'b' ونعود إلى S (A → bS) لنحصل على 'abS'. هذا يخلق دورة تولد (ab) بشكل متكرر. اللغة هي (ab)+a."
    },
    {
        "question": "إذا كانت اللغة L غير منتظمة، فهل يمكن أن تكون اللغة L* (إغلاق كلين) منتظمة؟",
        "options": [
            "نعم، دائماً",
            "نعم، في بعض الحالات",
            "لا، أبداً",
            "فقط إذا كانت L محدودة"
        ],
        "correctAnswerIndex": 1,
        "explanation": "نعم، هذا ممكن. على سبيل المثال، إذا كانت L = {a^p | p is a prime number} (لغة غير منتظمة)، فإن L* ستكون {a^n | n ≥ 2} وهي لغة منتظمة. إغلاق كلين يمكن أن 'يسوي' التعقيدات التي جعلت اللغة الأصلية غير منتظمة."
    },
    {
        "question": "الفرق بين الاشتقاق اليساري واليميني لنفس السلسلة في نموذج قواعدي غير غامض هو:",
        "options": [
            "ينتجان سلسلتين مختلفتين",
            "أحدهما أطول من الآخر",
            "كلاهما ينتج نفس السلسلة ونفس شجرة الاشتقاق، لكن بترتيب مختلف لتطبيق القواعد",
            "الاشتقاق اليساري فقط هو الصحيح"
        ],
        "correctAnswerIndex": 2,
        "explanation": "لكل سلسلة في لغة يولدها نموذج قواعدي غير غامض، يوجد اشتقاق يساري فريد واشتقاق يميني فريد، وكلاهما يتوافق مع نفس شجرة الاشتقاق الفريدة. الاختلاف يكمن فقط في ترتيب استبدال الرموز غير النهائية."
    },
    {
        "question": "ما هي الخطوة الأولى في خوارزمية تصغير الـ DFA؟",
        "options": [
            "إزالة الحالات التي لا يمكن الوصول إليها",
            "دمج جميع الحالات النهائية في حالة واحدة",
            "تقسيم الحالات إلى مجموعتين: نهائية وغير نهائية",
            "عكس جميع الانتقالات"
        ],
        "correctAnswerIndex": 2,
        "explanation": "تبدأ الخوارزمية بتقسيم أولي (Partition 0) للحالات إلى مجموعتين: مجموعة الحالات النهائية F، ومجموعة الحالات غير النهائية Q-F. هذا هو الأساس الذي تبنى عليه التقسيمات اللاحقة لتمييز الحالات."
    },
    {
        "question": "التعبير المنتظم (aa|bb)* يصف:",
        "options": [
            "جميع السلاسل ذات الطول الزوجي",
            "جميع السلاسل التي تتكون من أزواج من a أو أزواج من b",
            "جميع السلاسل التي تبدأ بـ aa أو bb",
            "جميع السلاسل التي تتناوب فيها a و b"
        ],
        "correctAnswerIndex": 1,
        "explanation": "الوحدة الأساسية في هذا التعبير هي إما 'aa' أو 'bb'. إغلاق كلين (*) يسمح بتكرار هذه الوحدات أي عدد من المرات بأي ترتيب. لذا، السلاسل الناتجة هي تجميعات من 'aa' و 'bb' مثل 'aabb', 'bbaabb', 'aaaa', 'ε'."
    },
    {
        "question": "في أي مرحلة من مراحل المترجم (compiler) يتم استخدام الأتوماتات المنتهية والتعابير المنتظمة بشكل أساسي؟",
        "options": [
            "التحليل المعجمي (Lexical Analysis)",
            "التحليل النحوي (Syntax Analysis / Parsing)",
            "التحليل الدلالي (Semantic Analysis)",
            "توليد الكود (Code Generation)"
        ],
        "correctAnswerIndex": 0,
        "explanation": "المحلل المعجمي (Lexical Analyzer أو Scanner) هو المسؤول عن تجميع سلسلة المحارف في البرنامج إلى وحدات ذات معنى تسمى 'tokens' (مثل الكلمات المفتاحية، المعرفات، الأرقام). هذه الـ tokens يتم تعريفها عادة باستخدام التعابير المنتظمة، ويتم التعرف عليها باستخدام أتوماتات منتهية."
    },
    {
        "question": "ماذا تمثل السلسلة الجملية (Sentential form) في سياق النماذج القواعدية؟",
        "options": [
            "سلسلة تحتوي على رموز نهائية فقط",
            "أي سلسلة يمكن اشتقاقها من رمز البداية، وقد تحتوي على رموز نهائية وغير نهائية",
            "قاعدة إنتاج واحدة",
            "لغة النموذج القواعدي بأكملها"
        ],
        "correctAnswerIndex": 1,
        "explanation": "السلسلة الجملية هي أي سلسلة من الرموز (نهائية وغير نهائية) يمكن الوصول إليها من رمز البداية S عبر صفر أو أكثر من خطوات الاشتقاق. اللغة L(G) هي مجموعة السلاسل الجملية التي تتكون من رموز نهائية فقط."
    },
    {
        "question": "لغة جميع السلاسل الثنائية التي لا تحتوي على ثلاث أصفار متتالية هي لغة:",
        "options": [
            "منتظمة",
            "خارجة عن السياق ولكنها ليست منتظمة",
            "ليست خارجة عن السياق",
            "منتهية"
        ],
        "correctAnswerIndex": 0,
        "explanation": "هذه اللغة منتظمة. يمكن بناء DFA بأربع حالات لتتبع عدد الأصفار المتتالية التي تمت رؤيتها حتى الآن (0 أصفار، 1 صفر، 2 أصفار، 3 أصفار أو أكثر وهي حالة ميتة). بما أنه يمكن بناء DFA لها، فهي منتظمة."
    }
]
